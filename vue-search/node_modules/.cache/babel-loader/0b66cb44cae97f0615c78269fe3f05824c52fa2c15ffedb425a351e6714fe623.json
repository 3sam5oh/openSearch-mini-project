{"ast":null,"code":"/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst BaseConnectionPool = require('./BaseConnectionPool');\nconst assert = require('assert');\nconst debug = require('debug')('opensearch');\nconst Connection = require('../Connection');\nconst noop = () => {};\nclass ConnectionPool extends BaseConnectionPool {\n  constructor(opts) {\n    super(opts);\n    this.dead = [];\n    // the resurrect timeout is 60s\n    this.resurrectTimeout = 1000 * 60;\n    // number of consecutive failures after which\n    // the timeout doesn't increase\n    this.resurrectTimeoutCutoff = 5;\n    this.pingTimeout = opts.pingTimeout;\n    this._sniffEnabled = opts.sniffEnabled || false;\n    const resurrectStrategy = opts.resurrectStrategy || 'ping';\n    this.resurrectStrategy = ConnectionPool.resurrectStrategies[resurrectStrategy];\n    assert(this.resurrectStrategy != null, `Invalid resurrection strategy: '${resurrectStrategy}'`);\n  }\n\n  /**\n   * Marks a connection as 'alive'.\n   * If needed removes the connection from the dead list\n   * and then resets the `deadCount`.\n   *\n   * @param {object} connection\n   */\n  markAlive(connection) {\n    const {\n      id\n    } = connection;\n    debug(`Marking as 'alive' connection '${id}'`);\n    const index = this.dead.indexOf(id);\n    if (index > -1) this.dead.splice(index, 1);\n    connection.status = Connection.statuses.ALIVE;\n    connection.deadCount = 0;\n    connection.resurrectTimeout = 0;\n    return this;\n  }\n\n  /**\n   * Marks a connection as 'dead'.\n   * If needed, adds the connection to the dead list\n   * and then increments the `deadCount`.\n   *\n   * @param {object} connection\n   */\n  markDead(connection) {\n    const {\n      id\n    } = connection;\n    debug(`Marking as 'dead' connection '${id}'`);\n    if (this.dead.indexOf(id) === -1) {\n      // It might happen that `markDead` is called just after\n      // a pool update, and in such case we will add to the dead\n      // list a node that no longer exists. The following check verifies\n      // that the connection is still part of the pool before\n      // marking it as dead.\n      for (let i = 0; i < this.size; i++) {\n        if (this.connections[i].id === id) {\n          this.dead.push(id);\n          break;\n        }\n      }\n    }\n    connection.status = Connection.statuses.DEAD;\n    connection.deadCount++;\n    // resurrectTimeout formula:\n    // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`\n    connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff));\n\n    // sort the dead list in ascending order\n    // based on the resurrectTimeout\n    this.dead.sort((a, b) => {\n      const conn1 = this.connections.find(c => c.id === a);\n      const conn2 = this.connections.find(c => c.id === b);\n      return conn1.resurrectTimeout - conn2.resurrectTimeout;\n    });\n    return this;\n  }\n\n  /**\n   * If enabled, tries to resurrect a connection with the given\n   * resurrect strategy ('ping', 'optimistic', 'none').\n   *\n   * @param {object} { now, requestId }\n   * @param {function} callback (isAlive, connection)\n   */\n  resurrect(opts, callback = noop) {\n    if (this.resurrectStrategy === 0 || this.dead.length === 0) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    }\n\n    // the dead list is sorted in ascending order based on the timeout\n    // so the first element will always be the one with the smaller timeout\n    const connection = this.connections.find(c => c.id === this.dead[0]);\n    if ((opts.now || Date.now()) < connection.resurrectTimeout) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    }\n    const {\n      id\n    } = connection;\n\n    // ping strategy\n    if (this.resurrectStrategy === 1) {\n      connection.request({\n        method: 'HEAD',\n        path: '/',\n        timeout: this.pingTimeout\n      }, (err, response) => {\n        let isAlive = true;\n        const statusCode = response !== null ? response.statusCode : 0;\n        if (err != null || statusCode === 502 || statusCode === 503 || statusCode === 504) {\n          debug(`Resurrect: connection '${id}' is still dead`);\n          this.markDead(connection);\n          isAlive = false;\n        } else {\n          debug(`Resurrect: connection '${id}' is now alive`);\n          this.markAlive(connection);\n        }\n        this.emit('resurrect', null, {\n          strategy: 'ping',\n          name: opts.name,\n          request: {\n            id: opts.requestId\n          },\n          isAlive,\n          connection\n        });\n        callback(isAlive, connection);\n      });\n      // optimistic strategy\n    } else {\n      debug(`Resurrect: optimistic resurrection for connection '${id}'`);\n      this.dead.splice(this.dead.indexOf(id), 1);\n      connection.status = Connection.statuses.ALIVE;\n      this.emit('resurrect', null, {\n        strategy: 'optimistic',\n        name: opts.name,\n        request: {\n          id: opts.requestId\n        },\n        isAlive: true,\n        connection\n      });\n      callback(true, connection); // eslint-disable-line\n    }\n  }\n\n  /**\n   * Returns an alive connection if present,\n   * otherwise returns a dead connection.\n   * By default it filters the `cluster_manager` or `master` only nodes.\n   * It uses the selector to choose which\n   * connection return.\n   *\n   * @param {object} options (filter and selector)\n   * @returns {object|null} connection\n   */\n  getConnection(opts = {}) {\n    const filter = opts.filter || (() => true);\n    const selector = opts.selector || (c => c[0]);\n    this.resurrect({\n      now: opts.now,\n      requestId: opts.requestId,\n      name: opts.name\n    });\n    const noAliveConnections = this.size === this.dead.length;\n\n    // TODO: can we cache this?\n    const connections = [];\n    for (let i = 0; i < this.size; i++) {\n      const connection = this.connections[i];\n      if (noAliveConnections || connection.status === Connection.statuses.ALIVE) {\n        if (filter(connection) === true) {\n          connections.push(connection);\n        }\n      }\n    }\n    if (connections.length === 0) return null;\n    return selector(connections);\n  }\n\n  /**\n   * Empties the connection pool.\n   *\n   * @returns {ConnectionPool}\n   */\n  empty(callback = noop) {\n    super.empty(() => {\n      this.dead = [];\n      callback();\n    });\n  }\n\n  /**\n   * Update the ConnectionPool with new connections.\n   *\n   * @param {array} array of connections\n   * @returns {ConnectionPool}\n   */\n  update(connections) {\n    super.update(connections);\n    this.dead = [];\n    return this;\n  }\n}\nConnectionPool.resurrectStrategies = {\n  none: 0,\n  ping: 1,\n  optimistic: 2\n};\nmodule.exports = ConnectionPool;","map":{"version":3,"names":["require","BaseConnectionPool","assert","debug","Connection","noop","ConnectionPool","constructor","opts","dead","resurrectTimeout","resurrectTimeoutCutoff","pingTimeout","_sniffEnabled","sniffEnabled","resurrectStrategy","resurrectStrategies","markAlive","connection","id","index","indexOf","splice","status","statuses","ALIVE","deadCount","markDead","i","size","connections","push","DEAD","Date","now","Math","pow","min","sort","a","b","conn1","find","c","conn2","resurrect","callback","length","request","method","path","timeout","err","response","isAlive","statusCode","emit","strategy","name","requestId","getConnection","filter","selector","noAliveConnections","empty","update","none","ping","optimistic","module","exports"],"sources":["C:/search/vue-search/node_modules/@opensearch-project/opensearch/lib/pool/ConnectionPool.js"],"sourcesContent":["/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nconst BaseConnectionPool = require('./BaseConnectionPool');\nconst assert = require('assert');\nconst debug = require('debug')('opensearch');\nconst Connection = require('../Connection');\nconst noop = () => {};\n\nclass ConnectionPool extends BaseConnectionPool {\n  constructor(opts) {\n    super(opts);\n\n    this.dead = [];\n    // the resurrect timeout is 60s\n    this.resurrectTimeout = 1000 * 60;\n    // number of consecutive failures after which\n    // the timeout doesn't increase\n    this.resurrectTimeoutCutoff = 5;\n    this.pingTimeout = opts.pingTimeout;\n    this._sniffEnabled = opts.sniffEnabled || false;\n\n    const resurrectStrategy = opts.resurrectStrategy || 'ping';\n    this.resurrectStrategy = ConnectionPool.resurrectStrategies[resurrectStrategy];\n    assert(this.resurrectStrategy != null, `Invalid resurrection strategy: '${resurrectStrategy}'`);\n  }\n\n  /**\n   * Marks a connection as 'alive'.\n   * If needed removes the connection from the dead list\n   * and then resets the `deadCount`.\n   *\n   * @param {object} connection\n   */\n  markAlive(connection) {\n    const { id } = connection;\n    debug(`Marking as 'alive' connection '${id}'`);\n    const index = this.dead.indexOf(id);\n    if (index > -1) this.dead.splice(index, 1);\n    connection.status = Connection.statuses.ALIVE;\n    connection.deadCount = 0;\n    connection.resurrectTimeout = 0;\n    return this;\n  }\n\n  /**\n   * Marks a connection as 'dead'.\n   * If needed, adds the connection to the dead list\n   * and then increments the `deadCount`.\n   *\n   * @param {object} connection\n   */\n  markDead(connection) {\n    const { id } = connection;\n    debug(`Marking as 'dead' connection '${id}'`);\n    if (this.dead.indexOf(id) === -1) {\n      // It might happen that `markDead` is called just after\n      // a pool update, and in such case we will add to the dead\n      // list a node that no longer exists. The following check verifies\n      // that the connection is still part of the pool before\n      // marking it as dead.\n      for (let i = 0; i < this.size; i++) {\n        if (this.connections[i].id === id) {\n          this.dead.push(id);\n          break;\n        }\n      }\n    }\n    connection.status = Connection.statuses.DEAD;\n    connection.deadCount++;\n    // resurrectTimeout formula:\n    // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`\n    connection.resurrectTimeout =\n      Date.now() +\n      this.resurrectTimeout *\n        Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff));\n\n    // sort the dead list in ascending order\n    // based on the resurrectTimeout\n    this.dead.sort((a, b) => {\n      const conn1 = this.connections.find((c) => c.id === a);\n      const conn2 = this.connections.find((c) => c.id === b);\n      return conn1.resurrectTimeout - conn2.resurrectTimeout;\n    });\n\n    return this;\n  }\n\n  /**\n   * If enabled, tries to resurrect a connection with the given\n   * resurrect strategy ('ping', 'optimistic', 'none').\n   *\n   * @param {object} { now, requestId }\n   * @param {function} callback (isAlive, connection)\n   */\n  resurrect(opts, callback = noop) {\n    if (this.resurrectStrategy === 0 || this.dead.length === 0) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    }\n\n    // the dead list is sorted in ascending order based on the timeout\n    // so the first element will always be the one with the smaller timeout\n    const connection = this.connections.find((c) => c.id === this.dead[0]);\n    if ((opts.now || Date.now()) < connection.resurrectTimeout) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    }\n\n    const { id } = connection;\n\n    // ping strategy\n    if (this.resurrectStrategy === 1) {\n      connection.request(\n        {\n          method: 'HEAD',\n          path: '/',\n          timeout: this.pingTimeout,\n        },\n        (err, response) => {\n          let isAlive = true;\n          const statusCode = response !== null ? response.statusCode : 0;\n          if (err != null || statusCode === 502 || statusCode === 503 || statusCode === 504) {\n            debug(`Resurrect: connection '${id}' is still dead`);\n            this.markDead(connection);\n            isAlive = false;\n          } else {\n            debug(`Resurrect: connection '${id}' is now alive`);\n            this.markAlive(connection);\n          }\n          this.emit('resurrect', null, {\n            strategy: 'ping',\n            name: opts.name,\n            request: { id: opts.requestId },\n            isAlive,\n            connection,\n          });\n          callback(isAlive, connection);\n        }\n      );\n      // optimistic strategy\n    } else {\n      debug(`Resurrect: optimistic resurrection for connection '${id}'`);\n      this.dead.splice(this.dead.indexOf(id), 1);\n      connection.status = Connection.statuses.ALIVE;\n      this.emit('resurrect', null, {\n        strategy: 'optimistic',\n        name: opts.name,\n        request: { id: opts.requestId },\n        isAlive: true,\n        connection,\n      });\n      callback(true, connection); // eslint-disable-line\n    }\n  }\n\n  /**\n   * Returns an alive connection if present,\n   * otherwise returns a dead connection.\n   * By default it filters the `cluster_manager` or `master` only nodes.\n   * It uses the selector to choose which\n   * connection return.\n   *\n   * @param {object} options (filter and selector)\n   * @returns {object|null} connection\n   */\n  getConnection(opts = {}) {\n    const filter = opts.filter || (() => true);\n    const selector = opts.selector || ((c) => c[0]);\n\n    this.resurrect({\n      now: opts.now,\n      requestId: opts.requestId,\n      name: opts.name,\n    });\n\n    const noAliveConnections = this.size === this.dead.length;\n\n    // TODO: can we cache this?\n    const connections = [];\n    for (let i = 0; i < this.size; i++) {\n      const connection = this.connections[i];\n      if (noAliveConnections || connection.status === Connection.statuses.ALIVE) {\n        if (filter(connection) === true) {\n          connections.push(connection);\n        }\n      }\n    }\n\n    if (connections.length === 0) return null;\n\n    return selector(connections);\n  }\n\n  /**\n   * Empties the connection pool.\n   *\n   * @returns {ConnectionPool}\n   */\n  empty(callback = noop) {\n    super.empty(() => {\n      this.dead = [];\n      callback();\n    });\n  }\n\n  /**\n   * Update the ConnectionPool with new connections.\n   *\n   * @param {array} array of connections\n   * @returns {ConnectionPool}\n   */\n  update(connections) {\n    super.update(connections);\n    this.dead = [];\n    return this;\n  }\n}\n\nConnectionPool.resurrectStrategies = {\n  none: 0,\n  ping: 1,\n  optimistic: 2,\n};\n\nmodule.exports = ConnectionPool;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}