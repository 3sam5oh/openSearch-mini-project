{"ast":null,"code":"/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\n/* eslint camelcase: 0 */\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/web.immediate.js\");\nconst {\n  Readable\n} = require('stream');\nconst {\n  promisify\n} = require('util');\nconst {\n  ResponseError,\n  ConfigurationError\n} = require('./errors');\nconst pImmediate = promisify(setImmediate);\nconst sleep = promisify(setTimeout);\nconst kClient = Symbol('opensearch-client');\nconst kMetaHeader = Symbol('meta header');\n/* istanbul ignore next */\nconst noop = () => {};\nclass Helpers {\n  constructor(opts) {\n    this[kClient] = opts.client;\n    this[kMetaHeader] = opts.metaHeader;\n    this.maxRetries = opts.maxRetries;\n  }\n\n  /**\n   * Runs a search operation. The only difference between client.search and this utility,\n   * is that we are only returning the hits to the user and not the full OpenSearch response.\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n   * as it will only need the documents source.\n   * @param {object} params - The OpenSearch's search parameters.\n   * @param {object} options - The client optional configuration for this request.\n   * @return {array} The documents that matched the request.\n   */\n  async search(params, options) {\n    appendFilterPath('hits.hits._source', params, true);\n    const {\n      body\n    } = await this[kClient].search(params, options);\n    if (body.hits && body.hits.hits) {\n      return body.hits.hits.map(d => d._source);\n    }\n    return [];\n  }\n\n  /**\n   * Runs a scroll search operation. This function returns an async iterator, allowing\n   * the user to use a for await loop to get all the results of a given search.\n   * ```js\n   * for await (const result of client.helpers.scrollSearch({ params })) {\n   *   console.log(result)\n   * }\n   * ```\n   * Each result represents the entire body of a single scroll search request,\n   * if you just need to scroll the results, use scrollDocuments.\n   * This function handles automatically retries on 429 status code.\n   * @param {object} params - The OpenSearch's search parameters.\n   * @param {object} options - The client optional configuration for this request.\n   * @return {iterator} the async iterator\n   */\n  async *scrollSearch(params, options = {}) {\n    if (this[kMetaHeader] !== null) {\n      options.headers = options.headers || {};\n    }\n    // TODO: study scroll search slices\n    const wait = options.wait || 5000;\n    const maxRetries = options.maxRetries || this.maxRetries;\n    if (Array.isArray(options.ignore)) {\n      options.ignore.push(429);\n    } else {\n      options.ignore = [429];\n    }\n    params.scroll = params.scroll || '1m';\n    appendFilterPath('_scroll_id', params, false);\n    let response = null;\n    for (let i = 0; i <= maxRetries; i++) {\n      response = await this[kClient].search(params, options);\n      if (response.statusCode !== 429) break;\n      await sleep(wait);\n    }\n    if (response.statusCode === 429) {\n      throw new ResponseError(response);\n    }\n    let scroll_id = response.body._scroll_id;\n    let stop = false;\n    const clear = async () => {\n      stop = true;\n      await this[kClient].clearScroll({\n        body: {\n          scroll_id\n        }\n      }, {\n        ignore: [400],\n        ...options\n      });\n    };\n    while (response.body.hits && response.body.hits.hits.length > 0) {\n      // scroll id is always present in the response, but it might\n      // change over time based on the number of shards\n      scroll_id = response.body._scroll_id;\n      response.clear = clear;\n      addDocumentsGetter(response);\n      yield response;\n      if (stop === true) {\n        break;\n      }\n      for (let i = 0; i <= maxRetries; i++) {\n        response = await this[kClient].scroll({\n          scroll: params.scroll,\n          rest_total_hits_as_int: params.rest_total_hits_as_int || params.restTotalHitsAsInt,\n          body: {\n            scroll_id\n          }\n        }, options);\n        if (response.statusCode !== 429) break;\n        await sleep(wait);\n      }\n      if (response.statusCode === 429) {\n        throw new ResponseError(response);\n      }\n    }\n    if (stop === false) {\n      await clear();\n    }\n  }\n\n  /**\n   * Runs a scroll search operation. This function returns an async iterator, allowing\n   * the user to use a for await loop to get all the documents of a given search.\n   * ```js\n   * for await (const document of client.helpers.scrollSearch({ params })) {\n   *   console.log(document)\n   * }\n   * ```\n   * Each document is what you will find by running a scrollSearch and iterating on the hits array.\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n   * as it will only need the documents source.\n   * @param {object} params - The OpenSearch's search parameters.\n   * @param {object} options - The client optional configuration for this request.\n   * @return {iterator} the async iterator\n   */\n  async *scrollDocuments(params, options) {\n    appendFilterPath('hits.hits._source', params, true);\n    for await (const {\n      documents\n    } of this.scrollSearch(params, options)) {\n      for (const document of documents) {\n        yield document;\n      }\n    }\n  }\n\n  /**\n   * Creates a msearch helper instance. Once you configure it, you can use the provided\n   * `search` method to add new searches in the queue.\n   * @param {object} options - The configuration of the msearch operations.\n   * @param {object} reqOptions - The client optional configuration for this request.\n   * @return {object} The possible operations to run.\n   */\n  msearch(options = {}, reqOptions = {}) {\n    const client = this[kClient];\n    const {\n      operations = 5,\n      concurrency = 5,\n      flushInterval = 500,\n      retries = this.maxRetries,\n      wait = 5000,\n      ...msearchOptions\n    } = options;\n    let stopReading = false;\n    let stopError = null;\n    let timeoutRef = null;\n    const operationsStream = new Readable({\n      objectMode: true,\n      read() {}\n    });\n    const p = iterate();\n    const helper = {\n      then(onFulfilled, onRejected) {\n        return p.then(onFulfilled, onRejected);\n      },\n      catch(onRejected) {\n        return p.catch(onRejected);\n      },\n      stop(error = null) {\n        if (stopReading === true) return;\n        stopReading = true;\n        stopError = error;\n        operationsStream.push(null);\n      },\n      // TODO: support abort a single search?\n      // NOTE: the validation checks are synchronous and the callback/promise will\n      //       be resolved in the same tick. We might want to fix this in the future.\n      search(header, body, callback) {\n        if (stopReading === true) {\n          const error = stopError === null ? new ConfigurationError('The msearch processor has been stopped') : stopError;\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n        if (!(typeof header === 'object' && header !== null && !Array.isArray(header))) {\n          const error = new ConfigurationError('The header should be an object');\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n        if (!(typeof body === 'object' && body !== null && !Array.isArray(body))) {\n          const error = new ConfigurationError('The body should be an object');\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n        let promise = null;\n        if (callback === undefined) {\n          let onFulfilled = null;\n          let onRejected = null;\n          promise = new Promise((resolve, reject) => {\n            onFulfilled = resolve;\n            onRejected = reject;\n          });\n          callback = function callback(err, result) {\n            err ? onRejected(err) : onFulfilled(result);\n          };\n        }\n        operationsStream.push([header, body, callback]);\n        if (promise !== null) {\n          return promise;\n        }\n      }\n    };\n    return helper;\n    async function iterate() {\n      const {\n        semaphore,\n        finish\n      } = buildSemaphore();\n      const msearchBody = [];\n      const callbacks = [];\n      let loadedOperations = 0;\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval);\n      for await (const operation of operationsStream) {\n        timeoutRef.refresh();\n        loadedOperations += 1;\n        msearchBody.push(operation[0], operation[1]);\n        callbacks.push(operation[2]);\n        if (loadedOperations >= operations) {\n          const send = await semaphore();\n          send(msearchBody.slice(), callbacks.slice());\n          msearchBody.length = 0;\n          callbacks.length = 0;\n          loadedOperations = 0;\n        }\n      }\n      clearTimeout(timeoutRef);\n      // In some cases the previos http call does not have finished,\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\n      if (loadedOperations > 0) {\n        const send = await semaphore();\n        send(msearchBody, callbacks);\n      }\n      await finish();\n      if (stopError !== null) {\n        throw stopError;\n      }\n      async function onFlushTimeout() {\n        if (loadedOperations === 0) return;\n        const msearchBodyCopy = msearchBody.slice();\n        const callbacksCopy = callbacks.slice();\n        msearchBody.length = 0;\n        callbacks.length = 0;\n        loadedOperations = 0;\n        try {\n          const send = await semaphore();\n          send(msearchBodyCopy, callbacksCopy);\n        } catch (err) {\n          /* istanbul ignore next */\n          helper.stop(err);\n        }\n      }\n    }\n\n    // This function builds a semaphore using the concurrency\n    // options of the msearch helper. It is used inside the iterator\n    // to guarantee that no more than the number of operations\n    // allowed to run at the same time are executed.\n    // It returns a semaphore function which resolves in the next tick\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\n    // a promise that resolves as soon as one of the running request has finshed.\n    // The semaphore function resolves a send function, which will be used\n    // to send the actual msearch request.\n    // It also returns a finish function, which returns a promise that is resolved\n    // when there are no longer request running.\n    function buildSemaphore() {\n      let resolveSemaphore = null;\n      let resolveFinish = null;\n      let running = 0;\n      return {\n        semaphore,\n        finish\n      };\n      function finish() {\n        return new Promise(resolve => {\n          if (running === 0) {\n            resolve();\n          } else {\n            resolveFinish = resolve;\n          }\n        });\n      }\n      function semaphore() {\n        if (running < concurrency) {\n          running += 1;\n          return pImmediate(send);\n        } else {\n          return new Promise(resolve => {\n            resolveSemaphore = resolve;\n          });\n        }\n      }\n      function send(msearchBody, callbacks) {\n        /* istanbul ignore if */\n        if (running > concurrency) {\n          throw new Error('Max concurrency reached');\n        }\n        msearchOperation(msearchBody, callbacks, () => {\n          running -= 1;\n          if (resolveSemaphore) {\n            running += 1;\n            resolveSemaphore(send);\n            resolveSemaphore = null;\n          } else if (resolveFinish && running === 0) {\n            resolveFinish();\n          }\n        });\n      }\n    }\n    function msearchOperation(msearchBody, callbacks, done) {\n      let retryCount = retries;\n\n      // Instead of going full on async-await, which would make the code easier to read,\n      // we have decided to use callback style instead.\n      // This because every time we use async await, V8 will create multiple promises\n      // behind the scenes, making the code slightly slower.\n      tryMsearch(msearchBody, callbacks, retrySearch);\n      function retrySearch(msearchBody, callbacks) {\n        if (msearchBody.length > 0 && retryCount > 0) {\n          retryCount -= 1;\n          setTimeout(tryMsearch, wait, msearchBody, callbacks, retrySearch);\n          return;\n        }\n        done();\n      }\n\n      // This function never returns an error, if the msearch operation fails,\n      // the error is dispatched to all search executors.\n      function tryMsearch(msearchBody, callbacks, done) {\n        client.msearch(Object.assign({}, msearchOptions, {\n          body: msearchBody\n        }), reqOptions, (err, results) => {\n          const retryBody = [];\n          const retryCallbacks = [];\n          if (err) {\n            addDocumentsGetter(results);\n            for (const callback of callbacks) {\n              callback(err, results);\n            }\n            return done(retryBody, retryCallbacks);\n          }\n          const {\n            responses\n          } = results.body;\n          for (let i = 0, len = responses.length; i < len; i++) {\n            const response = responses[i];\n            if (response.status === 429 && retryCount > 0) {\n              retryBody.push(msearchBody[i * 2]);\n              retryBody.push(msearchBody[i * 2 + 1]);\n              retryCallbacks.push(callbacks[i]);\n              continue;\n            }\n            const result = {\n              ...results,\n              body: response\n            };\n            addDocumentsGetter(result);\n            if (response.status >= 400) {\n              callbacks[i](new ResponseError(result), result);\n            } else {\n              callbacks[i](null, result);\n            }\n          }\n          done(retryBody, retryCallbacks);\n        });\n      }\n    }\n  }\n\n  /**\n   * Creates a bulk helper instance. Once you configure it, you can pick which operation\n   * to execute with the given dataset, index, create, update, and delete.\n   * @param {object} options - The configuration of the bulk operation.\n   * @param {object} reqOptions - The client optional configuration for this request.\n   * @return {object} The possible operations to run with the datasource.\n   */\n  bulk(options, reqOptions = {}) {\n    const client = this[kClient];\n    const {\n      serializer\n    } = client;\n    if (this[kMetaHeader] !== null) {\n      reqOptions.headers = reqOptions.headers || {};\n    }\n    const {\n      datasource,\n      onDocument,\n      flushBytes = 5000000,\n      flushInterval = 30000,\n      concurrency = 5,\n      retries = this.maxRetries,\n      wait = 5000,\n      onDrop = noop,\n      refreshOnCompletion = false,\n      ...bulkOptions\n    } = options;\n    if (datasource === undefined) {\n      return Promise.reject(new ConfigurationError('bulk helper: the datasource is required'));\n    }\n    if (!(Array.isArray(datasource) || Buffer.isBuffer(datasource) || typeof datasource.pipe === 'function' || datasource[Symbol.asyncIterator])) {\n      return Promise.reject(new ConfigurationError('bulk helper: the datasource must be an array or a buffer or a readable stream or an async generator'));\n    }\n    if (onDocument === undefined) {\n      return Promise.reject(new ConfigurationError('bulk helper: the onDocument callback is required'));\n    }\n    let shouldAbort = false;\n    let timeoutRef = null;\n    const stats = {\n      total: 0,\n      failed: 0,\n      retry: 0,\n      successful: 0,\n      noop: 0,\n      time: 0,\n      bytes: 0,\n      aborted: false\n    };\n    const p = iterate();\n    const helper = {\n      get stats() {\n        return stats;\n      },\n      then(onFulfilled, onRejected) {\n        return p.then(onFulfilled, onRejected);\n      },\n      catch(onRejected) {\n        return p.catch(onRejected);\n      },\n      abort() {\n        clearTimeout(timeoutRef);\n        shouldAbort = true;\n        stats.aborted = true;\n        return this;\n      }\n    };\n    return helper;\n\n    /**\n     * Function that iterates over the given datasource and start a bulk operation as soon\n     * as it reaches the configured bulk size. It's designed to use the Node.js asynchronous\n     * model at this maximum capacity, as it will collect the next body to send while there is\n     * a running http call. In this way, the CPU time will be used carefully.\n     * The objects will be serialized right away, to approximate the byte length of the body.\n     * It creates an array of strings instead of a ndjson string because the bulkOperation\n     * will navigate the body for matching failed operations with the original document.\n     */\n    async function iterate() {\n      const {\n        semaphore,\n        finish\n      } = buildSemaphore();\n      const startTime = Date.now();\n      const bulkBody = [];\n      let actionBody = '';\n      let payloadBody = '';\n      let chunkBytes = 0;\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval);\n      for await (const chunk of datasource) {\n        if (shouldAbort === true) break;\n        timeoutRef.refresh();\n        const result = onDocument(chunk);\n        const [action, payload] = Array.isArray(result) ? result : [result, chunk];\n        const operation = Object.keys(action)[0];\n        if (operation === 'index' || operation === 'create') {\n          actionBody = serializer.serialize(action);\n          payloadBody = typeof payload === 'string' ? payload : serializer.serialize(payload);\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n          bulkBody.push(actionBody, payloadBody);\n        } else if (operation === 'update') {\n          actionBody = serializer.serialize(action);\n          payloadBody = typeof chunk === 'string' ? `{\"doc\":${chunk}}` : serializer.serialize({\n            doc: chunk,\n            ...payload\n          });\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n          bulkBody.push(actionBody, payloadBody);\n        } else if (operation === 'delete') {\n          actionBody = serializer.serialize(action);\n          chunkBytes += Buffer.byteLength(actionBody);\n          bulkBody.push(actionBody);\n        } else {\n          clearTimeout(timeoutRef);\n          throw new ConfigurationError(`Bulk helper invalid action: '${operation}'`);\n        }\n        if (chunkBytes >= flushBytes) {\n          stats.bytes += chunkBytes;\n          const send = await semaphore();\n          send(bulkBody.slice());\n          bulkBody.length = 0;\n          chunkBytes = 0;\n        }\n      }\n      clearTimeout(timeoutRef);\n      // In some cases the previos http call does not have finished,\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\n      if (shouldAbort === false && chunkBytes > 0) {\n        const send = await semaphore();\n        stats.bytes += chunkBytes;\n        send(bulkBody);\n      }\n      await finish();\n      if (refreshOnCompletion) {\n        await client.indices.refresh({\n          index: typeof refreshOnCompletion === 'string' ? refreshOnCompletion : '_all'\n        }, reqOptions);\n      }\n      stats.time = Date.now() - startTime;\n      stats.total = stats.successful + stats.failed;\n      return stats;\n      async function onFlushTimeout() {\n        if (chunkBytes === 0) return;\n        stats.bytes += chunkBytes;\n        const bulkBodyCopy = bulkBody.slice();\n        bulkBody.length = 0;\n        chunkBytes = 0;\n        try {\n          const send = await semaphore();\n          send(bulkBodyCopy);\n        } catch (err) {\n          /* istanbul ignore next */\n          helper.abort();\n        }\n      }\n    }\n\n    // This function builds a semaphore using the concurrency\n    // options of the bulk helper. It is used inside the iterator\n    // to guarantee that no more than the number of operations\n    // allowed to run at the same time are executed.\n    // It returns a semaphore function which resolves in the next tick\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\n    // a promise that resolves as soon as one of the running request has finshed.\n    // The semaphore function resolves a send function, which will be used\n    // to send the actual bulk request.\n    // It also returns a finish function, which returns a promise that is resolved\n    // when there are no longer request running. It rejects an error if one\n    // of the request has failed for some reason.\n    function buildSemaphore() {\n      let resolveSemaphore = null;\n      let resolveFinish = null;\n      let rejectFinish = null;\n      let error = null;\n      let running = 0;\n      return {\n        semaphore,\n        finish\n      };\n      function finish() {\n        return new Promise((resolve, reject) => {\n          if (running === 0) {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          } else {\n            resolveFinish = resolve;\n            rejectFinish = reject;\n          }\n        });\n      }\n      function semaphore() {\n        if (running < concurrency) {\n          running += 1;\n          return pImmediate(send);\n        } else {\n          return new Promise(resolve => {\n            resolveSemaphore = resolve;\n          });\n        }\n      }\n      function send(bulkBody) {\n        /* istanbul ignore if */\n        if (running > concurrency) {\n          throw new Error('Max concurrency reached');\n        }\n        bulkOperation(bulkBody, err => {\n          running -= 1;\n          if (err) {\n            shouldAbort = true;\n            error = err;\n          }\n          if (resolveSemaphore) {\n            running += 1;\n            resolveSemaphore(send);\n            resolveSemaphore = null;\n          } else if (resolveFinish && running === 0) {\n            if (error) {\n              rejectFinish(error);\n            } else {\n              resolveFinish();\n            }\n          }\n        });\n      }\n    }\n    function bulkOperation(bulkBody, callback) {\n      let retryCount = retries;\n      let isRetrying = false;\n\n      // Instead of going full on async-await, which would make the code easier to read,\n      // we have decided to use callback style instead.\n      // This because every time we use async await, V8 will create multiple promises\n      // behind the scenes, making the code slightly slower.\n      tryBulk(bulkBody, retryDocuments);\n      function retryDocuments(err, bulkBody) {\n        if (err) return callback(err);\n        if (shouldAbort === true) return callback();\n        if (bulkBody.length > 0) {\n          if (retryCount > 0) {\n            isRetrying = true;\n            retryCount -= 1;\n            stats.retry += bulkBody.length;\n            setTimeout(tryBulk, wait, bulkBody, retryDocuments);\n            return;\n          }\n          for (let i = 0, len = bulkBody.length; i < len; i = i + 2) {\n            const operation = Object.keys(serializer.deserialize(bulkBody[i]))[0];\n            onDrop({\n              status: 429,\n              error: null,\n              operation: serializer.deserialize(bulkBody[i]),\n              document: operation !== 'delete' ? serializer.deserialize(bulkBody[i + 1]) : /* istanbul ignore next */\n              null,\n              retried: isRetrying\n            });\n            stats.failed += 1;\n          }\n        }\n        callback();\n      }\n      function tryBulk(bulkBody, callback) {\n        if (shouldAbort === true) return callback(null, []);\n        client.bulk(Object.assign({}, bulkOptions, {\n          body: bulkBody\n        }), reqOptions, (err, {\n          body\n        }) => {\n          if (err) return callback(err, null);\n          if (body.errors === false) {\n            stats.successful += body.items.length;\n            for (const item of body.items) {\n              if (item.update && item.update.result === 'noop') {\n                stats.noop++;\n              }\n            }\n            return callback(null, []);\n          }\n          const retry = [];\n          const {\n            items\n          } = body;\n          for (let i = 0, len = items.length; i < len; i++) {\n            const action = items[i];\n            const operation = Object.keys(action)[0];\n            const {\n              status\n            } = action[operation];\n            const indexSlice = operation !== 'delete' ? i * 2 : i;\n            if (status >= 400) {\n              // 429 is the only staus code where we might want to retry\n              // a document, because it was not an error in the document itself,\n              // but the OpenSearch node were handling too many operations.\n              if (status === 429) {\n                retry.push(bulkBody[indexSlice]);\n                /* istanbul ignore next */\n                if (operation !== 'delete') {\n                  retry.push(bulkBody[indexSlice + 1]);\n                }\n              } else {\n                onDrop({\n                  status: status,\n                  error: action[operation].error,\n                  operation: serializer.deserialize(bulkBody[indexSlice]),\n                  document: operation !== 'delete' ? serializer.deserialize(bulkBody[indexSlice + 1]) : null,\n                  retried: isRetrying\n                });\n                stats.failed += 1;\n              }\n            } else {\n              stats.successful += 1;\n            }\n          }\n          callback(null, retry);\n        });\n      }\n    }\n  }\n}\n\n// Using a getter will improve the overall performances of the code,\n// as we will reed the documents only if needed.\nfunction addDocumentsGetter(result) {\n  Object.defineProperty(result, 'documents', {\n    get() {\n      if (this.body.hits && this.body.hits.hits) {\n        return this.body.hits.hits.map(d => d._source);\n      }\n      return [];\n    }\n  });\n}\nfunction appendFilterPath(filter, params, force) {\n  if (params.filter_path !== undefined) {\n    params.filter_path += ',' + filter;\n  } else if (params.filterPath !== undefined) {\n    params.filterPath += ',' + filter;\n  } else if (force === true) {\n    params.filter_path = filter;\n  }\n}\nmodule.exports = Helpers;","map":{"version":3,"names":["require","Readable","promisify","ResponseError","ConfigurationError","pImmediate","setImmediate","sleep","setTimeout","kClient","Symbol","kMetaHeader","noop","Helpers","constructor","opts","client","metaHeader","maxRetries","search","params","options","appendFilterPath","body","hits","map","d","_source","scrollSearch","headers","wait","Array","isArray","ignore","push","scroll","response","i","statusCode","scroll_id","_scroll_id","stop","clear","clearScroll","length","addDocumentsGetter","rest_total_hits_as_int","restTotalHitsAsInt","scrollDocuments","documents","document","msearch","reqOptions","operations","concurrency","flushInterval","retries","msearchOptions","stopReading","stopError","timeoutRef","operationsStream","objectMode","read","p","iterate","helper","then","onFulfilled","onRejected","catch","error","header","callback","Promise","reject","promise","undefined","resolve","err","result","semaphore","finish","buildSemaphore","msearchBody","callbacks","loadedOperations","onFlushTimeout","operation","refresh","send","slice","clearTimeout","msearchBodyCopy","callbacksCopy","resolveSemaphore","resolveFinish","running","Error","msearchOperation","done","retryCount","tryMsearch","retrySearch","Object","assign","results","retryBody","retryCallbacks","responses","len","status","bulk","serializer","datasource","onDocument","flushBytes","onDrop","refreshOnCompletion","bulkOptions","Buffer","isBuffer","pipe","asyncIterator","shouldAbort","stats","total","failed","retry","successful","time","bytes","aborted","abort","startTime","Date","now","bulkBody","actionBody","payloadBody","chunkBytes","chunk","action","payload","keys","serialize","byteLength","doc","indices","index","bulkBodyCopy","rejectFinish","bulkOperation","isRetrying","tryBulk","retryDocuments","deserialize","retried","errors","items","item","update","indexSlice","defineProperty","get","filter","force","filter_path","filterPath","module","exports"],"sources":["C:/search/vue-search/node_modules/@opensearch-project/opensearch/lib/Helpers.js"],"sourcesContent":["/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\n/* eslint camelcase: 0 */\n\nconst { Readable } = require('stream');\nconst { promisify } = require('util');\nconst { ResponseError, ConfigurationError } = require('./errors');\n\nconst pImmediate = promisify(setImmediate);\nconst sleep = promisify(setTimeout);\nconst kClient = Symbol('opensearch-client');\nconst kMetaHeader = Symbol('meta header');\n/* istanbul ignore next */\nconst noop = () => {};\n\nclass Helpers {\n  constructor(opts) {\n    this[kClient] = opts.client;\n    this[kMetaHeader] = opts.metaHeader;\n    this.maxRetries = opts.maxRetries;\n  }\n\n  /**\n   * Runs a search operation. The only difference between client.search and this utility,\n   * is that we are only returning the hits to the user and not the full OpenSearch response.\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n   * as it will only need the documents source.\n   * @param {object} params - The OpenSearch's search parameters.\n   * @param {object} options - The client optional configuration for this request.\n   * @return {array} The documents that matched the request.\n   */\n  async search(params, options) {\n    appendFilterPath('hits.hits._source', params, true);\n    const { body } = await this[kClient].search(params, options);\n    if (body.hits && body.hits.hits) {\n      return body.hits.hits.map((d) => d._source);\n    }\n    return [];\n  }\n\n  /**\n   * Runs a scroll search operation. This function returns an async iterator, allowing\n   * the user to use a for await loop to get all the results of a given search.\n   * ```js\n   * for await (const result of client.helpers.scrollSearch({ params })) {\n   *   console.log(result)\n   * }\n   * ```\n   * Each result represents the entire body of a single scroll search request,\n   * if you just need to scroll the results, use scrollDocuments.\n   * This function handles automatically retries on 429 status code.\n   * @param {object} params - The OpenSearch's search parameters.\n   * @param {object} options - The client optional configuration for this request.\n   * @return {iterator} the async iterator\n   */\n  async *scrollSearch(params, options = {}) {\n    if (this[kMetaHeader] !== null) {\n      options.headers = options.headers || {};\n    }\n    // TODO: study scroll search slices\n    const wait = options.wait || 5000;\n    const maxRetries = options.maxRetries || this.maxRetries;\n    if (Array.isArray(options.ignore)) {\n      options.ignore.push(429);\n    } else {\n      options.ignore = [429];\n    }\n    params.scroll = params.scroll || '1m';\n    appendFilterPath('_scroll_id', params, false);\n\n    let response = null;\n    for (let i = 0; i <= maxRetries; i++) {\n      response = await this[kClient].search(params, options);\n      if (response.statusCode !== 429) break;\n      await sleep(wait);\n    }\n    if (response.statusCode === 429) {\n      throw new ResponseError(response);\n    }\n\n    let scroll_id = response.body._scroll_id;\n    let stop = false;\n    const clear = async () => {\n      stop = true;\n      await this[kClient].clearScroll({ body: { scroll_id } }, { ignore: [400], ...options });\n    };\n\n    while (response.body.hits && response.body.hits.hits.length > 0) {\n      // scroll id is always present in the response, but it might\n      // change over time based on the number of shards\n      scroll_id = response.body._scroll_id;\n      response.clear = clear;\n      addDocumentsGetter(response);\n\n      yield response;\n\n      if (stop === true) {\n        break;\n      }\n\n      for (let i = 0; i <= maxRetries; i++) {\n        response = await this[kClient].scroll(\n          {\n            scroll: params.scroll,\n            rest_total_hits_as_int: params.rest_total_hits_as_int || params.restTotalHitsAsInt,\n            body: { scroll_id },\n          },\n          options\n        );\n        if (response.statusCode !== 429) break;\n        await sleep(wait);\n      }\n      if (response.statusCode === 429) {\n        throw new ResponseError(response);\n      }\n    }\n\n    if (stop === false) {\n      await clear();\n    }\n  }\n\n  /**\n   * Runs a scroll search operation. This function returns an async iterator, allowing\n   * the user to use a for await loop to get all the documents of a given search.\n   * ```js\n   * for await (const document of client.helpers.scrollSearch({ params })) {\n   *   console.log(document)\n   * }\n   * ```\n   * Each document is what you will find by running a scrollSearch and iterating on the hits array.\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n   * as it will only need the documents source.\n   * @param {object} params - The OpenSearch's search parameters.\n   * @param {object} options - The client optional configuration for this request.\n   * @return {iterator} the async iterator\n   */\n  async *scrollDocuments(params, options) {\n    appendFilterPath('hits.hits._source', params, true);\n    for await (const { documents } of this.scrollSearch(params, options)) {\n      for (const document of documents) {\n        yield document;\n      }\n    }\n  }\n\n  /**\n   * Creates a msearch helper instance. Once you configure it, you can use the provided\n   * `search` method to add new searches in the queue.\n   * @param {object} options - The configuration of the msearch operations.\n   * @param {object} reqOptions - The client optional configuration for this request.\n   * @return {object} The possible operations to run.\n   */\n  msearch(options = {}, reqOptions = {}) {\n    const client = this[kClient];\n    const {\n      operations = 5,\n      concurrency = 5,\n      flushInterval = 500,\n      retries = this.maxRetries,\n      wait = 5000,\n      ...msearchOptions\n    } = options;\n\n    let stopReading = false;\n    let stopError = null;\n    let timeoutRef = null;\n    const operationsStream = new Readable({\n      objectMode: true,\n      read() {},\n    });\n\n    const p = iterate();\n    const helper = {\n      then(onFulfilled, onRejected) {\n        return p.then(onFulfilled, onRejected);\n      },\n      catch(onRejected) {\n        return p.catch(onRejected);\n      },\n      stop(error = null) {\n        if (stopReading === true) return;\n        stopReading = true;\n        stopError = error;\n        operationsStream.push(null);\n      },\n      // TODO: support abort a single search?\n      // NOTE: the validation checks are synchronous and the callback/promise will\n      //       be resolved in the same tick. We might want to fix this in the future.\n      search(header, body, callback) {\n        if (stopReading === true) {\n          const error =\n            stopError === null\n              ? new ConfigurationError('The msearch processor has been stopped')\n              : stopError;\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n\n        if (!(typeof header === 'object' && header !== null && !Array.isArray(header))) {\n          const error = new ConfigurationError('The header should be an object');\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n\n        if (!(typeof body === 'object' && body !== null && !Array.isArray(body))) {\n          const error = new ConfigurationError('The body should be an object');\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n\n        let promise = null;\n        if (callback === undefined) {\n          let onFulfilled = null;\n          let onRejected = null;\n          promise = new Promise((resolve, reject) => {\n            onFulfilled = resolve;\n            onRejected = reject;\n          });\n          callback = function callback(err, result) {\n            err ? onRejected(err) : onFulfilled(result);\n          };\n        }\n\n        operationsStream.push([header, body, callback]);\n\n        if (promise !== null) {\n          return promise;\n        }\n      },\n    };\n\n    return helper;\n\n    async function iterate() {\n      const { semaphore, finish } = buildSemaphore();\n      const msearchBody = [];\n      const callbacks = [];\n      let loadedOperations = 0;\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval);\n\n      for await (const operation of operationsStream) {\n        timeoutRef.refresh();\n        loadedOperations += 1;\n        msearchBody.push(operation[0], operation[1]);\n        callbacks.push(operation[2]);\n        if (loadedOperations >= operations) {\n          const send = await semaphore();\n          send(msearchBody.slice(), callbacks.slice());\n          msearchBody.length = 0;\n          callbacks.length = 0;\n          loadedOperations = 0;\n        }\n      }\n\n      clearTimeout(timeoutRef);\n      // In some cases the previos http call does not have finished,\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\n      if (loadedOperations > 0) {\n        const send = await semaphore();\n        send(msearchBody, callbacks);\n      }\n\n      await finish();\n\n      if (stopError !== null) {\n        throw stopError;\n      }\n\n      async function onFlushTimeout() {\n        if (loadedOperations === 0) return;\n        const msearchBodyCopy = msearchBody.slice();\n        const callbacksCopy = callbacks.slice();\n        msearchBody.length = 0;\n        callbacks.length = 0;\n        loadedOperations = 0;\n        try {\n          const send = await semaphore();\n          send(msearchBodyCopy, callbacksCopy);\n        } catch (err) {\n          /* istanbul ignore next */\n          helper.stop(err);\n        }\n      }\n    }\n\n    // This function builds a semaphore using the concurrency\n    // options of the msearch helper. It is used inside the iterator\n    // to guarantee that no more than the number of operations\n    // allowed to run at the same time are executed.\n    // It returns a semaphore function which resolves in the next tick\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\n    // a promise that resolves as soon as one of the running request has finshed.\n    // The semaphore function resolves a send function, which will be used\n    // to send the actual msearch request.\n    // It also returns a finish function, which returns a promise that is resolved\n    // when there are no longer request running.\n    function buildSemaphore() {\n      let resolveSemaphore = null;\n      let resolveFinish = null;\n      let running = 0;\n\n      return { semaphore, finish };\n\n      function finish() {\n        return new Promise((resolve) => {\n          if (running === 0) {\n            resolve();\n          } else {\n            resolveFinish = resolve;\n          }\n        });\n      }\n\n      function semaphore() {\n        if (running < concurrency) {\n          running += 1;\n          return pImmediate(send);\n        } else {\n          return new Promise((resolve) => {\n            resolveSemaphore = resolve;\n          });\n        }\n      }\n\n      function send(msearchBody, callbacks) {\n        /* istanbul ignore if */\n        if (running > concurrency) {\n          throw new Error('Max concurrency reached');\n        }\n        msearchOperation(msearchBody, callbacks, () => {\n          running -= 1;\n          if (resolveSemaphore) {\n            running += 1;\n            resolveSemaphore(send);\n            resolveSemaphore = null;\n          } else if (resolveFinish && running === 0) {\n            resolveFinish();\n          }\n        });\n      }\n    }\n\n    function msearchOperation(msearchBody, callbacks, done) {\n      let retryCount = retries;\n\n      // Instead of going full on async-await, which would make the code easier to read,\n      // we have decided to use callback style instead.\n      // This because every time we use async await, V8 will create multiple promises\n      // behind the scenes, making the code slightly slower.\n      tryMsearch(msearchBody, callbacks, retrySearch);\n      function retrySearch(msearchBody, callbacks) {\n        if (msearchBody.length > 0 && retryCount > 0) {\n          retryCount -= 1;\n          setTimeout(tryMsearch, wait, msearchBody, callbacks, retrySearch);\n          return;\n        }\n\n        done();\n      }\n\n      // This function never returns an error, if the msearch operation fails,\n      // the error is dispatched to all search executors.\n      function tryMsearch(msearchBody, callbacks, done) {\n        client.msearch(\n          Object.assign({}, msearchOptions, { body: msearchBody }),\n          reqOptions,\n          (err, results) => {\n            const retryBody = [];\n            const retryCallbacks = [];\n            if (err) {\n              addDocumentsGetter(results);\n              for (const callback of callbacks) {\n                callback(err, results);\n              }\n              return done(retryBody, retryCallbacks);\n            }\n            const { responses } = results.body;\n            for (let i = 0, len = responses.length; i < len; i++) {\n              const response = responses[i];\n              if (response.status === 429 && retryCount > 0) {\n                retryBody.push(msearchBody[i * 2]);\n                retryBody.push(msearchBody[i * 2 + 1]);\n                retryCallbacks.push(callbacks[i]);\n                continue;\n              }\n              const result = { ...results, body: response };\n              addDocumentsGetter(result);\n              if (response.status >= 400) {\n                callbacks[i](new ResponseError(result), result);\n              } else {\n                callbacks[i](null, result);\n              }\n            }\n            done(retryBody, retryCallbacks);\n          }\n        );\n      }\n    }\n  }\n\n  /**\n   * Creates a bulk helper instance. Once you configure it, you can pick which operation\n   * to execute with the given dataset, index, create, update, and delete.\n   * @param {object} options - The configuration of the bulk operation.\n   * @param {object} reqOptions - The client optional configuration for this request.\n   * @return {object} The possible operations to run with the datasource.\n   */\n  bulk(options, reqOptions = {}) {\n    const client = this[kClient];\n    const { serializer } = client;\n    if (this[kMetaHeader] !== null) {\n      reqOptions.headers = reqOptions.headers || {};\n    }\n    const {\n      datasource,\n      onDocument,\n      flushBytes = 5000000,\n      flushInterval = 30000,\n      concurrency = 5,\n      retries = this.maxRetries,\n      wait = 5000,\n      onDrop = noop,\n      refreshOnCompletion = false,\n      ...bulkOptions\n    } = options;\n\n    if (datasource === undefined) {\n      return Promise.reject(new ConfigurationError('bulk helper: the datasource is required'));\n    }\n    if (\n      !(\n        Array.isArray(datasource) ||\n        Buffer.isBuffer(datasource) ||\n        typeof datasource.pipe === 'function' ||\n        datasource[Symbol.asyncIterator]\n      )\n    ) {\n      return Promise.reject(\n        new ConfigurationError(\n          'bulk helper: the datasource must be an array or a buffer or a readable stream or an async generator'\n        )\n      );\n    }\n    if (onDocument === undefined) {\n      return Promise.reject(\n        new ConfigurationError('bulk helper: the onDocument callback is required')\n      );\n    }\n\n    let shouldAbort = false;\n    let timeoutRef = null;\n    const stats = {\n      total: 0,\n      failed: 0,\n      retry: 0,\n      successful: 0,\n      noop: 0,\n      time: 0,\n      bytes: 0,\n      aborted: false,\n    };\n\n    const p = iterate();\n    const helper = {\n      get stats() {\n        return stats;\n      },\n      then(onFulfilled, onRejected) {\n        return p.then(onFulfilled, onRejected);\n      },\n      catch(onRejected) {\n        return p.catch(onRejected);\n      },\n      abort() {\n        clearTimeout(timeoutRef);\n        shouldAbort = true;\n        stats.aborted = true;\n        return this;\n      },\n    };\n\n    return helper;\n\n    /**\n     * Function that iterates over the given datasource and start a bulk operation as soon\n     * as it reaches the configured bulk size. It's designed to use the Node.js asynchronous\n     * model at this maximum capacity, as it will collect the next body to send while there is\n     * a running http call. In this way, the CPU time will be used carefully.\n     * The objects will be serialized right away, to approximate the byte length of the body.\n     * It creates an array of strings instead of a ndjson string because the bulkOperation\n     * will navigate the body for matching failed operations with the original document.\n     */\n    async function iterate() {\n      const { semaphore, finish } = buildSemaphore();\n      const startTime = Date.now();\n      const bulkBody = [];\n      let actionBody = '';\n      let payloadBody = '';\n      let chunkBytes = 0;\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval);\n\n      for await (const chunk of datasource) {\n        if (shouldAbort === true) break;\n        timeoutRef.refresh();\n        const result = onDocument(chunk);\n        const [action, payload] = Array.isArray(result) ? result : [result, chunk];\n        const operation = Object.keys(action)[0];\n        if (operation === 'index' || operation === 'create') {\n          actionBody = serializer.serialize(action);\n          payloadBody = typeof payload === 'string' ? payload : serializer.serialize(payload);\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n          bulkBody.push(actionBody, payloadBody);\n        } else if (operation === 'update') {\n          actionBody = serializer.serialize(action);\n          payloadBody =\n            typeof chunk === 'string'\n              ? `{\"doc\":${chunk}}`\n              : serializer.serialize({ doc: chunk, ...payload });\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n          bulkBody.push(actionBody, payloadBody);\n        } else if (operation === 'delete') {\n          actionBody = serializer.serialize(action);\n          chunkBytes += Buffer.byteLength(actionBody);\n          bulkBody.push(actionBody);\n        } else {\n          clearTimeout(timeoutRef);\n          throw new ConfigurationError(`Bulk helper invalid action: '${operation}'`);\n        }\n\n        if (chunkBytes >= flushBytes) {\n          stats.bytes += chunkBytes;\n          const send = await semaphore();\n          send(bulkBody.slice());\n          bulkBody.length = 0;\n          chunkBytes = 0;\n        }\n      }\n\n      clearTimeout(timeoutRef);\n      // In some cases the previos http call does not have finished,\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\n      if (shouldAbort === false && chunkBytes > 0) {\n        const send = await semaphore();\n        stats.bytes += chunkBytes;\n        send(bulkBody);\n      }\n\n      await finish();\n\n      if (refreshOnCompletion) {\n        await client.indices.refresh(\n          {\n            index: typeof refreshOnCompletion === 'string' ? refreshOnCompletion : '_all',\n          },\n          reqOptions\n        );\n      }\n\n      stats.time = Date.now() - startTime;\n      stats.total = stats.successful + stats.failed;\n\n      return stats;\n\n      async function onFlushTimeout() {\n        if (chunkBytes === 0) return;\n        stats.bytes += chunkBytes;\n        const bulkBodyCopy = bulkBody.slice();\n        bulkBody.length = 0;\n        chunkBytes = 0;\n        try {\n          const send = await semaphore();\n          send(bulkBodyCopy);\n        } catch (err) {\n          /* istanbul ignore next */\n          helper.abort();\n        }\n      }\n    }\n\n    // This function builds a semaphore using the concurrency\n    // options of the bulk helper. It is used inside the iterator\n    // to guarantee that no more than the number of operations\n    // allowed to run at the same time are executed.\n    // It returns a semaphore function which resolves in the next tick\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\n    // a promise that resolves as soon as one of the running request has finshed.\n    // The semaphore function resolves a send function, which will be used\n    // to send the actual bulk request.\n    // It also returns a finish function, which returns a promise that is resolved\n    // when there are no longer request running. It rejects an error if one\n    // of the request has failed for some reason.\n    function buildSemaphore() {\n      let resolveSemaphore = null;\n      let resolveFinish = null;\n      let rejectFinish = null;\n      let error = null;\n      let running = 0;\n\n      return { semaphore, finish };\n\n      function finish() {\n        return new Promise((resolve, reject) => {\n          if (running === 0) {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          } else {\n            resolveFinish = resolve;\n            rejectFinish = reject;\n          }\n        });\n      }\n\n      function semaphore() {\n        if (running < concurrency) {\n          running += 1;\n          return pImmediate(send);\n        } else {\n          return new Promise((resolve) => {\n            resolveSemaphore = resolve;\n          });\n        }\n      }\n\n      function send(bulkBody) {\n        /* istanbul ignore if */\n        if (running > concurrency) {\n          throw new Error('Max concurrency reached');\n        }\n        bulkOperation(bulkBody, (err) => {\n          running -= 1;\n          if (err) {\n            shouldAbort = true;\n            error = err;\n          }\n          if (resolveSemaphore) {\n            running += 1;\n            resolveSemaphore(send);\n            resolveSemaphore = null;\n          } else if (resolveFinish && running === 0) {\n            if (error) {\n              rejectFinish(error);\n            } else {\n              resolveFinish();\n            }\n          }\n        });\n      }\n    }\n\n    function bulkOperation(bulkBody, callback) {\n      let retryCount = retries;\n      let isRetrying = false;\n\n      // Instead of going full on async-await, which would make the code easier to read,\n      // we have decided to use callback style instead.\n      // This because every time we use async await, V8 will create multiple promises\n      // behind the scenes, making the code slightly slower.\n      tryBulk(bulkBody, retryDocuments);\n      function retryDocuments(err, bulkBody) {\n        if (err) return callback(err);\n        if (shouldAbort === true) return callback();\n\n        if (bulkBody.length > 0) {\n          if (retryCount > 0) {\n            isRetrying = true;\n            retryCount -= 1;\n            stats.retry += bulkBody.length;\n            setTimeout(tryBulk, wait, bulkBody, retryDocuments);\n            return;\n          }\n          for (let i = 0, len = bulkBody.length; i < len; i = i + 2) {\n            const operation = Object.keys(serializer.deserialize(bulkBody[i]))[0];\n            onDrop({\n              status: 429,\n              error: null,\n              operation: serializer.deserialize(bulkBody[i]),\n              document:\n                operation !== 'delete'\n                  ? serializer.deserialize(bulkBody[i + 1])\n                  : /* istanbul ignore next */\n                    null,\n              retried: isRetrying,\n            });\n            stats.failed += 1;\n          }\n        }\n        callback();\n      }\n\n      function tryBulk(bulkBody, callback) {\n        if (shouldAbort === true) return callback(null, []);\n        client.bulk(\n          Object.assign({}, bulkOptions, { body: bulkBody }),\n          reqOptions,\n          (err, { body }) => {\n            if (err) return callback(err, null);\n            if (body.errors === false) {\n              stats.successful += body.items.length;\n              for (const item of body.items) {\n                if (item.update && item.update.result === 'noop') {\n                  stats.noop++;\n                }\n              }\n              return callback(null, []);\n            }\n            const retry = [];\n            const { items } = body;\n            for (let i = 0, len = items.length; i < len; i++) {\n              const action = items[i];\n              const operation = Object.keys(action)[0];\n              const { status } = action[operation];\n              const indexSlice = operation !== 'delete' ? i * 2 : i;\n\n              if (status >= 400) {\n                // 429 is the only staus code where we might want to retry\n                // a document, because it was not an error in the document itself,\n                // but the OpenSearch node were handling too many operations.\n                if (status === 429) {\n                  retry.push(bulkBody[indexSlice]);\n                  /* istanbul ignore next */\n                  if (operation !== 'delete') {\n                    retry.push(bulkBody[indexSlice + 1]);\n                  }\n                } else {\n                  onDrop({\n                    status: status,\n                    error: action[operation].error,\n                    operation: serializer.deserialize(bulkBody[indexSlice]),\n                    document:\n                      operation !== 'delete'\n                        ? serializer.deserialize(bulkBody[indexSlice + 1])\n                        : null,\n                    retried: isRetrying,\n                  });\n                  stats.failed += 1;\n                }\n              } else {\n                stats.successful += 1;\n              }\n            }\n            callback(null, retry);\n          }\n        );\n      }\n    }\n  }\n}\n\n// Using a getter will improve the overall performances of the code,\n// as we will reed the documents only if needed.\nfunction addDocumentsGetter(result) {\n  Object.defineProperty(result, 'documents', {\n    get() {\n      if (this.body.hits && this.body.hits.hits) {\n        return this.body.hits.hits.map((d) => d._source);\n      }\n      return [];\n    },\n  });\n}\n\nfunction appendFilterPath(filter, params, force) {\n  if (params.filter_path !== undefined) {\n    params.filter_path += ',' + filter;\n  } else if (params.filterPath !== undefined) {\n    params.filterPath += ',' + filter;\n  } else if (force === true) {\n    params.filter_path = filter;\n  }\n}\n\nmodule.exports = Helpers;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}