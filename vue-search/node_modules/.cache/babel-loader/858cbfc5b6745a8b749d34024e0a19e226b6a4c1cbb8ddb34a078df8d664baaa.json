{"ast":null,"code":"/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  URL\n} = require('url');\nconst debug = require('debug')('opensearch');\nconst Connection = require('../Connection');\nconst {\n  ConfigurationError\n} = require('../errors');\nconst noop = () => {};\nclass BaseConnectionPool {\n  constructor(opts) {\n    // list of nodes and weights\n    this.connections = [];\n    // how many nodes we have in our scheduler\n    this.size = this.connections.length;\n    this.Connection = opts.Connection;\n    this.emit = opts.emit || noop;\n    this.auth = opts.auth || null;\n    this._ssl = opts.ssl;\n    this._agent = opts.agent;\n    this._proxy = opts.proxy || null;\n  }\n  getConnection() {\n    throw new Error('getConnection must be implemented');\n  }\n  markAlive() {\n    return this;\n  }\n  markDead() {\n    return this;\n  }\n\n  /**\n   * Creates a new connection instance.\n   */\n  createConnection(opts) {\n    if (opts instanceof Connection) {\n      throw new ConfigurationError('The argument provided is already a Connection instance.');\n    }\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n    if (this.auth !== null) {\n      opts.auth = this.auth;\n    } else if (opts.url.username !== '' && opts.url.password !== '') {\n      opts.auth = {\n        username: decodeURIComponent(opts.url.username),\n        password: decodeURIComponent(opts.url.password)\n      };\n    }\n    if (opts.ssl == null) opts.ssl = this._ssl;\n    /* istanbul ignore else */\n    if (opts.agent == null) opts.agent = this._agent;\n    /* istanbul ignore else */\n    if (opts.proxy == null) opts.proxy = this._proxy;\n    const connection = new this.Connection(opts);\n    for (const conn of this.connections) {\n      if (conn.id === connection.id) {\n        throw new Error(`Connection with id '${connection.id}' is already present`);\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * Adds a new connection to the pool.\n   *\n   * @param {object|string} host\n   * @returns {ConnectionPool}\n   */\n  addConnection(opts) {\n    if (Array.isArray(opts)) {\n      opts.forEach(o => this.addConnection(o));\n      return;\n    }\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n    const connectionId = opts.id;\n    const connectionUrl = opts.url.href;\n    if (connectionId || connectionUrl) {\n      const connectionById = this.connections.find(c => c.id === connectionId);\n      const connectionByUrl = this.connections.find(c => c.id === connectionUrl);\n      if (connectionById || connectionByUrl) {\n        throw new ConfigurationError(`Connection with id '${connectionId || connectionUrl}' is already present`);\n      }\n    }\n    this.update([...this.connections, opts]);\n    return this.connections[this.size - 1];\n  }\n\n  /**\n   * Removes a new connection to the pool.\n   *\n   * @param {object} connection\n   * @returns {ConnectionPool}\n   */\n  removeConnection(connection) {\n    debug('Removing connection', connection);\n    return this.update(this.connections.filter(c => c.id !== connection.id));\n  }\n\n  /**\n   * Empties the connection pool.\n   */\n  empty(callback = noop) {\n    debug('Emptying the connection pool');\n    let openConnections = this.size;\n    this.connections.forEach(connection => {\n      connection.close(() => {\n        if (--openConnections === 0) {\n          this.connections = [];\n          this.size = this.connections.length;\n          callback();\n        }\n      });\n    });\n  }\n\n  /**\n   * Update the ConnectionPool with new connections.\n   *\n   * @param {array} array of connections\n   * @returns {ConnectionPool}\n   */\n  update(nodes) {\n    debug('Updating the connection pool');\n    const newConnections = [];\n    const oldConnections = [];\n    for (const node of nodes) {\n      // if we already have a given connection in the pool\n      // we mark it as alive and we do not close the connection\n      // to avoid socket issues\n      const connectionById = this.connections.find(c => c.id === node.id);\n      const connectionByUrl = this.connections.find(c => c.id === node.url.href);\n      if (connectionById) {\n        debug(`The connection with id '${node.id}' is already present`);\n        this.markAlive(connectionById);\n        newConnections.push(connectionById);\n        // in case the user has passed a single url (or an array of urls),\n        // the connection id will be the full href; to avoid closing valid connections\n        // because are not present in the pool, we check also the node url,\n        // and if is already present we update its id with the opensearch provided one.\n      } else if (connectionByUrl) {\n        connectionByUrl.id = node.id;\n        this.markAlive(connectionByUrl);\n        newConnections.push(connectionByUrl);\n      } else {\n        newConnections.push(this.createConnection(node));\n      }\n    }\n    const ids = nodes.map(c => c.id);\n    // remove all the dead connections and old connections\n    for (const connection of this.connections) {\n      if (ids.indexOf(connection.id) === -1) {\n        oldConnections.push(connection);\n      }\n    }\n\n    // close old connections\n    oldConnections.forEach(connection => connection.close());\n    this.connections = newConnections;\n    this.size = this.connections.length;\n    return this;\n  }\n\n  /**\n   * Transforms the nodes objects to a host object.\n   *\n   * @param {object} nodes\n   * @returns {array} hosts\n   */\n  nodesToHost(nodes, protocol) {\n    const ids = Object.keys(nodes);\n    const hosts = [];\n    for (let i = 0, len = ids.length; i < len; i++) {\n      const node = nodes[ids[i]];\n      // If there is no protocol in\n      // the `publish_address` new URL will throw\n      // the publish_address can have two forms:\n      //   - ip:port\n      //   - hostname/ip:port\n      // if we encounter the second case, we should\n      // use the hostname instead of the ip\n      let address = node.http.publish_address;\n      const parts = address.split('/');\n      // the url is in the form of hostname/ip:port\n      if (parts.length > 1) {\n        const hostname = parts[0];\n        const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);\n        address = `${hostname}:${port}`;\n      }\n      address = address.slice(0, 4) === 'http' ? /* istanbul ignore next */\n      address : `${protocol}//${address}`;\n      const roles = node.roles.reduce((acc, role) => {\n        acc[role] = true;\n        return acc;\n      }, {});\n      hosts.push({\n        url: new URL(address),\n        id: ids[i],\n        roles: Object.assign({\n          [Connection.roles.DATA]: false,\n          [Connection.roles.INGEST]: false\n        }, roles)\n      });\n    }\n    return hosts;\n  }\n\n  /**\n   * Transforms an url string to a host object\n   *\n   * @param {string} url\n   * @returns {object} host\n   */\n  urlToHost(url) {\n    return {\n      url: new URL(url)\n    };\n  }\n}\nmodule.exports = BaseConnectionPool;","map":{"version":3,"names":["require","URL","debug","Connection","ConfigurationError","noop","BaseConnectionPool","constructor","opts","connections","size","length","emit","auth","_ssl","ssl","_agent","agent","_proxy","proxy","getConnection","Error","markAlive","markDead","createConnection","urlToHost","url","username","password","decodeURIComponent","connection","conn","id","addConnection","Array","isArray","forEach","o","connectionId","connectionUrl","href","connectionById","find","c","connectionByUrl","update","removeConnection","filter","empty","callback","openConnections","close","nodes","newConnections","oldConnections","node","push","ids","map","indexOf","nodesToHost","protocol","Object","keys","hosts","i","len","address","http","publish_address","parts","split","hostname","port","match","slice","roles","reduce","acc","role","assign","DATA","INGEST","module","exports"],"sources":["C:/search/vue-search/node_modules/@opensearch-project/opensearch/lib/pool/BaseConnectionPool.js"],"sourcesContent":["/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nconst { URL } = require('url');\nconst debug = require('debug')('opensearch');\nconst Connection = require('../Connection');\nconst { ConfigurationError } = require('../errors');\nconst noop = () => {};\n\nclass BaseConnectionPool {\n  constructor(opts) {\n    // list of nodes and weights\n    this.connections = [];\n    // how many nodes we have in our scheduler\n    this.size = this.connections.length;\n    this.Connection = opts.Connection;\n    this.emit = opts.emit || noop;\n    this.auth = opts.auth || null;\n    this._ssl = opts.ssl;\n    this._agent = opts.agent;\n    this._proxy = opts.proxy || null;\n  }\n\n  getConnection() {\n    throw new Error('getConnection must be implemented');\n  }\n\n  markAlive() {\n    return this;\n  }\n\n  markDead() {\n    return this;\n  }\n\n  /**\n   * Creates a new connection instance.\n   */\n  createConnection(opts) {\n    if (opts instanceof Connection) {\n      throw new ConfigurationError('The argument provided is already a Connection instance.');\n    }\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n\n    if (this.auth !== null) {\n      opts.auth = this.auth;\n    } else if (opts.url.username !== '' && opts.url.password !== '') {\n      opts.auth = {\n        username: decodeURIComponent(opts.url.username),\n        password: decodeURIComponent(opts.url.password),\n      };\n    }\n\n    if (opts.ssl == null) opts.ssl = this._ssl;\n    /* istanbul ignore else */\n    if (opts.agent == null) opts.agent = this._agent;\n    /* istanbul ignore else */\n    if (opts.proxy == null) opts.proxy = this._proxy;\n\n    const connection = new this.Connection(opts);\n\n    for (const conn of this.connections) {\n      if (conn.id === connection.id) {\n        throw new Error(`Connection with id '${connection.id}' is already present`);\n      }\n    }\n\n    return connection;\n  }\n\n  /**\n   * Adds a new connection to the pool.\n   *\n   * @param {object|string} host\n   * @returns {ConnectionPool}\n   */\n  addConnection(opts) {\n    if (Array.isArray(opts)) {\n      opts.forEach((o) => this.addConnection(o));\n      return;\n    }\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n\n    const connectionId = opts.id;\n    const connectionUrl = opts.url.href;\n\n    if (connectionId || connectionUrl) {\n      const connectionById = this.connections.find((c) => c.id === connectionId);\n      const connectionByUrl = this.connections.find((c) => c.id === connectionUrl);\n\n      if (connectionById || connectionByUrl) {\n        throw new ConfigurationError(\n          `Connection with id '${connectionId || connectionUrl}' is already present`\n        );\n      }\n    }\n\n    this.update([...this.connections, opts]);\n    return this.connections[this.size - 1];\n  }\n\n  /**\n   * Removes a new connection to the pool.\n   *\n   * @param {object} connection\n   * @returns {ConnectionPool}\n   */\n  removeConnection(connection) {\n    debug('Removing connection', connection);\n    return this.update(this.connections.filter((c) => c.id !== connection.id));\n  }\n\n  /**\n   * Empties the connection pool.\n   */\n  empty(callback = noop) {\n    debug('Emptying the connection pool');\n    let openConnections = this.size;\n    this.connections.forEach((connection) => {\n      connection.close(() => {\n        if (--openConnections === 0) {\n          this.connections = [];\n          this.size = this.connections.length;\n          callback();\n        }\n      });\n    });\n  }\n\n  /**\n   * Update the ConnectionPool with new connections.\n   *\n   * @param {array} array of connections\n   * @returns {ConnectionPool}\n   */\n  update(nodes) {\n    debug('Updating the connection pool');\n    const newConnections = [];\n    const oldConnections = [];\n\n    for (const node of nodes) {\n      // if we already have a given connection in the pool\n      // we mark it as alive and we do not close the connection\n      // to avoid socket issues\n      const connectionById = this.connections.find((c) => c.id === node.id);\n      const connectionByUrl = this.connections.find((c) => c.id === node.url.href);\n      if (connectionById) {\n        debug(`The connection with id '${node.id}' is already present`);\n        this.markAlive(connectionById);\n        newConnections.push(connectionById);\n        // in case the user has passed a single url (or an array of urls),\n        // the connection id will be the full href; to avoid closing valid connections\n        // because are not present in the pool, we check also the node url,\n        // and if is already present we update its id with the opensearch provided one.\n      } else if (connectionByUrl) {\n        connectionByUrl.id = node.id;\n        this.markAlive(connectionByUrl);\n        newConnections.push(connectionByUrl);\n      } else {\n        newConnections.push(this.createConnection(node));\n      }\n    }\n\n    const ids = nodes.map((c) => c.id);\n    // remove all the dead connections and old connections\n    for (const connection of this.connections) {\n      if (ids.indexOf(connection.id) === -1) {\n        oldConnections.push(connection);\n      }\n    }\n\n    // close old connections\n    oldConnections.forEach((connection) => connection.close());\n\n    this.connections = newConnections;\n    this.size = this.connections.length;\n\n    return this;\n  }\n\n  /**\n   * Transforms the nodes objects to a host object.\n   *\n   * @param {object} nodes\n   * @returns {array} hosts\n   */\n  nodesToHost(nodes, protocol) {\n    const ids = Object.keys(nodes);\n    const hosts = [];\n\n    for (let i = 0, len = ids.length; i < len; i++) {\n      const node = nodes[ids[i]];\n      // If there is no protocol in\n      // the `publish_address` new URL will throw\n      // the publish_address can have two forms:\n      //   - ip:port\n      //   - hostname/ip:port\n      // if we encounter the second case, we should\n      // use the hostname instead of the ip\n      let address = node.http.publish_address;\n      const parts = address.split('/');\n      // the url is in the form of hostname/ip:port\n      if (parts.length > 1) {\n        const hostname = parts[0];\n        const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);\n        address = `${hostname}:${port}`;\n      }\n\n      address =\n        address.slice(0, 4) === 'http'\n          ? /* istanbul ignore next */\n            address\n          : `${protocol}//${address}`;\n      const roles = node.roles.reduce((acc, role) => {\n        acc[role] = true;\n        return acc;\n      }, {});\n\n      hosts.push({\n        url: new URL(address),\n        id: ids[i],\n        roles: Object.assign(\n          {\n            [Connection.roles.DATA]: false,\n            [Connection.roles.INGEST]: false,\n          },\n          roles\n        ),\n      });\n    }\n\n    return hosts;\n  }\n\n  /**\n   * Transforms an url string to a host object\n   *\n   * @param {string} url\n   * @returns {object} host\n   */\n  urlToHost(url) {\n    return {\n      url: new URL(url),\n    };\n  }\n}\n\nmodule.exports = BaseConnectionPool;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}