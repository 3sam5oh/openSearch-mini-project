{"ast":null,"code":"/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst debug = require('debug')('opensearch');\nconst os = require('os');\nconst {\n  gzip,\n  unzip,\n  createGzip\n} = require('zlib');\nconst buffer = require('buffer');\nconst ms = require('ms');\nconst {\n  EventEmitter\n} = require('events');\nconst {\n  ConnectionError,\n  RequestAbortedError,\n  NoLivingConnectionsError,\n  ResponseError,\n  ConfigurationError\n} = require('./errors');\nconst noop = () => {};\nconst compatibleCheckEmitter = new EventEmitter();\nconst clientVersion = require('../package.json').version;\nconst userAgent = `opensearch-js/${clientVersion} (${os.platform()} ${os.release()}-${os.arch()}; Node.js ${process.version})`;\nconst MAX_BUFFER_LENGTH = buffer.constants.MAX_LENGTH;\nconst MAX_STRING_LENGTH = buffer.constants.MAX_STRING_LENGTH;\nconst HEAP_SIZE_LIMIT = require('v8').getHeapStatistics().heap_size_limit;\nconst kCompatibleCheck = Symbol('compatible check');\nconst kApiVersioning = Symbol('api versioning');\n\n/** Default Transport Layer */\nclass Transport {\n  constructor(opts) {\n    if (typeof opts.compression === 'string' && opts.compression !== 'gzip') {\n      throw new ConfigurationError(`Invalid compression: '${opts.compression}'`);\n    }\n    this.emit = opts.emit;\n    this.connectionPool = opts.connectionPool;\n    this.serializer = opts.serializer;\n    this.maxRetries = opts.maxRetries;\n    this.requestTimeout = toMs(opts.requestTimeout);\n    this.suggestCompression = opts.suggestCompression === true;\n    this.compression = opts.compression || false;\n    this.context = opts.context || null;\n    this.headers = Object.assign({}, {\n      'user-agent': userAgent\n    }, opts.suggestCompression === true ? {\n      'accept-encoding': 'gzip,deflate'\n    } : null, lowerCaseHeaders(opts.headers));\n    this.sniffInterval = opts.sniffInterval;\n    this.sniffOnConnectionFault = opts.sniffOnConnectionFault;\n    this.sniffEndpoint = opts.sniffEndpoint;\n    this.generateRequestId = opts.generateRequestId || generateRequestId();\n    this.name = opts.name;\n    this.opaqueIdPrefix = opts.opaqueIdPrefix;\n    this[kCompatibleCheck] = 0; // 0 = to be checked, 1 = checking, 2 = checked-ok, 3 checked-notok\n    this[kApiVersioning] = process.env.OPENSEARCH_CLIENT_APIVERSIONING === 'true';\n    this.memoryCircuitBreaker = opts.memoryCircuitBreaker;\n    this.nodeFilter = opts.nodeFilter || defaultNodeFilter;\n    if (typeof opts.nodeSelector === 'function') {\n      this.nodeSelector = opts.nodeSelector;\n    } else if (opts.nodeSelector === 'round-robin') {\n      this.nodeSelector = roundRobinSelector();\n    } else if (opts.nodeSelector === 'random') {\n      this.nodeSelector = randomSelector;\n    } else {\n      this.nodeSelector = roundRobinSelector();\n    }\n    this._sniffEnabled = typeof this.sniffInterval === 'number';\n    this._nextSniff = this._sniffEnabled ? Date.now() + this.sniffInterval : 0;\n    this._isSniffing = false;\n    this._auth = opts.auth;\n    if (opts.sniffOnStart === true) {\n      // timer needed otherwise it will clash\n      // with the compatible check testing\n      setTimeout(() => {\n        this.sniff({\n          reason: Transport.sniffReasons.SNIFF_ON_START\n        });\n      }, 10);\n    }\n  }\n\n  /**\n   * @param {Object} params\n   * @param {string} params.method - HTTP Method (e.g. HEAD, GET, POST...)\n   * @param {string} params.path - Relative URL path\n   * @param {Object | string} [params.body] - Body of a standard request.\n   * @param {Object[] | string} [params.bulkBody] - Body of a bulk request.\n   * @param {Object[] | string} [params.querystring] - Querystring params.\n   *\n   * @param {Object} options\n   * @param {number} [options.id] - Request ID\n   * @param {Object} [options.context] - Object used for observability\n   * @param {number} [options.maxRetries] - Max number of retries\n   * @param {false | 'gzip'} [options.compression] - Request body compression, if any\n   * @param {boolean} [options.asStream] - Whether to emit the response as stream\n   * @param {number[]} [options.ignore] - Response's Error Status Codes to ignore\n   * @param {Object} [options.headers] - Request headers\n   * @param {Object | string} [options.querystring] - Request's query string\n   * @param {number} [options.requestTimeout] - Max request timeout in milliseconds\n   *\n   * @param {function} callback - Callback that handles errors and response\n   */\n  request(params, options, callback) {\n    options = options || {};\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    let p = null;\n\n    // promises support\n    if (callback === undefined) {\n      let onFulfilled = null;\n      let onRejected = null;\n      p = new Promise((resolve, reject) => {\n        onFulfilled = resolve;\n        onRejected = reject;\n      });\n      callback = function callback(err, result) {\n        err ? onRejected(err) : onFulfilled(result);\n      };\n    }\n    const meta = {\n      context: null,\n      request: {\n        params: null,\n        options: null,\n        id: options.id || this.generateRequestId(params, options)\n      },\n      name: this.name,\n      connection: null,\n      attempts: 0,\n      aborted: false\n    };\n    if (this.context != null && options.context != null) {\n      meta.context = Object.assign({}, this.context, options.context);\n    } else if (this.context != null) {\n      meta.context = this.context;\n    } else if (options.context != null) {\n      meta.context = options.context;\n    }\n    const result = {\n      body: null,\n      statusCode: null,\n      headers: null,\n      meta\n    };\n    Object.defineProperty(result, 'warnings', {\n      get() {\n        return this.headers && this.headers.warning ? this.headers.warning.split(/(?!\\B\"[^\"]*),(?![^\"]*\"\\B)/) : null;\n      }\n    });\n\n    // We should not retry if we are sending a stream body, because we should store in memory\n    // a copy of the stream to be able to send it again, but since we don't know in advance\n    // the size of the stream, we risk to take too much memory.\n    // Furthermore, copying everytime the stream is very a expensive operation.\n    const maxRetries = isStream(params.body) || isStream(params.bulkBody) ? 0 : typeof options.maxRetries === 'number' ? options.maxRetries : this.maxRetries;\n    const compression = options.compression !== undefined ? options.compression : this.compression;\n    let request = {\n      abort: noop\n    };\n    const transportReturn = {\n      then(onFulfilled, onRejected) {\n        if (p != null) {\n          return p.then(onFulfilled, onRejected);\n        }\n      },\n      catch(onRejected) {\n        if (p != null) {\n          return p.catch(onRejected);\n        }\n      },\n      abort() {\n        meta.aborted = true;\n        request.abort();\n        debug('Aborting request', params);\n        return this;\n      },\n      finally(onFinally) {\n        if (p != null) {\n          return p.finally(onFinally);\n        }\n      }\n    };\n    const makeRequest = () => {\n      if (meta.aborted === true) {\n        return process.nextTick(callback, new RequestAbortedError(), result);\n      }\n      meta.connection = this.getConnection({\n        requestId: meta.request.id\n      });\n      if (meta.connection == null) {\n        return process.nextTick(callback, new NoLivingConnectionsError(), result);\n      }\n      this.emit('request', null, result);\n      // perform the actual http request\n      request = meta.connection.request(params, onResponse);\n    };\n    const onConnectionError = err => {\n      if (err.name !== 'RequestAbortedError') {\n        // if there is an error in the connection\n        // let's mark the connection as dead\n        this.connectionPool.markDead(meta.connection);\n        if (this.sniffOnConnectionFault === true) {\n          this.sniff({\n            reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,\n            requestId: meta.request.id\n          });\n        }\n\n        // retry logic\n        if (meta.attempts < maxRetries) {\n          meta.attempts++;\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n          makeRequest();\n          return;\n        }\n      }\n      err.meta = result;\n      this.emit('response', err, result);\n      return callback(err, result);\n    };\n    const onResponse = (err, response) => {\n      if (err !== null) {\n        return onConnectionError(err);\n      }\n      result.statusCode = response.statusCode;\n      result.headers = response.headers;\n      if (options.asStream === true) {\n        result.body = response;\n        this.emit('response', null, result);\n        callback(null, result);\n        return;\n      }\n      const contentEncoding = (result.headers['content-encoding'] || '').toLowerCase();\n      const isCompressed = contentEncoding.indexOf('gzip') > -1 || contentEncoding.indexOf('deflate') > -1;\n      /* istanbul ignore else */\n      if (result.headers['content-length'] !== undefined) {\n        const contentLength = Number(result.headers['content-length']);\n        // nodeJS data type limit check\n        if (isCompressed && contentLength > MAX_BUFFER_LENGTH) {\n          response.destroy();\n          return onConnectionError(new RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${MAX_BUFFER_LENGTH})`, result));\n        } else if (contentLength > MAX_STRING_LENGTH) {\n          response.destroy();\n          return onConnectionError(new RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${MAX_STRING_LENGTH})`, result));\n        } else if (shouldApplyCircuitBreaker(contentLength)) {\n          // Abort this response to avoid OOM crash of dashboards.\n          response.destroy();\n          return onConnectionError(new RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed heap memory limit.`, result));\n        }\n      }\n      // if the response is compressed, we must handle it\n      // as buffer for allowing decompression later\n      let payload = isCompressed ? [] : '';\n      const onData = isCompressed ? chunk => {\n        payload.push(chunk);\n      } : chunk => {\n        payload += chunk;\n      };\n      const onEnd = err => {\n        response.removeListener('data', onData);\n        response.removeListener('end', onEnd);\n        response.removeListener('error', onEnd);\n        response.removeListener('aborted', onAbort);\n        if (err) {\n          return onConnectionError(new ConnectionError(err.message));\n        }\n        if (isCompressed) {\n          unzip(Buffer.concat(payload), onBody);\n        } else {\n          onBody(null, payload);\n        }\n      };\n      const onAbort = () => {\n        response.destroy();\n        onEnd(new Error('Response aborted while reading the body'));\n      };\n      if (!isCompressed) {\n        response.setEncoding('utf8');\n      }\n      this.emit('deserialization', null, result);\n      response.on('data', onData);\n      response.on('error', onEnd);\n      response.on('end', onEnd);\n      response.on('aborted', onAbort);\n    };\n    // Helper function to check if memory circuit breaker enabled and the response payload is too large to fit into available heap memory.\n    const shouldApplyCircuitBreaker = contentLength => {\n      if (!this.memoryCircuitBreaker || !this.memoryCircuitBreaker.enabled) return false;\n      const maxPercentage = validateMemoryPercentage(this.memoryCircuitBreaker.maxPercentage);\n      const heapUsed = process.memoryUsage().heapUsed;\n      return contentLength + heapUsed > HEAP_SIZE_LIMIT * maxPercentage;\n    };\n    const onBody = (err, payload) => {\n      if (err) {\n        this.emit('response', err, result);\n        return callback(err, result);\n      }\n      if (Buffer.isBuffer(payload)) {\n        payload = payload.toString();\n      }\n      const isHead = params.method === 'HEAD';\n      // we should attempt the payload deserialization only if:\n      //    - a `content-type` is defined and is equal to `application/json`\n      //    - the request is not a HEAD request\n      //    - the payload is not an empty string\n      if (result.headers['content-type'] !== undefined && (result.headers['content-type'].indexOf('application/json') > -1 || result.headers['content-type'].indexOf('application/vnd.opensearch+json') > -1) && isHead === false && payload !== '') {\n        try {\n          result.body = this.serializer.deserialize(payload);\n        } catch (err) {\n          this.emit('response', err, result);\n          return callback(err, result);\n        }\n      } else {\n        // cast to boolean if the request method was HEAD and there was no error\n        result.body = isHead === true && result.statusCode < 400 ? true : payload;\n      }\n\n      // we should ignore the statusCode if the user has configured the `ignore` field with\n      // the statusCode we just got or if the request method is HEAD and the statusCode is 404\n      const ignoreStatusCode = Array.isArray(options.ignore) && options.ignore.indexOf(result.statusCode) > -1 || isHead === true && result.statusCode === 404;\n      if (ignoreStatusCode === false && (result.statusCode === 502 || result.statusCode === 503 || result.statusCode === 504)) {\n        // if the statusCode is 502/3/4 we should run our retry strategy\n        // and mark the connection as dead\n        this.connectionPool.markDead(meta.connection);\n        // retry logic (we should not retry on \"429 - Too Many Requests\")\n        if (meta.attempts < maxRetries && result.statusCode !== 429) {\n          meta.attempts++;\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n          makeRequest();\n          return;\n        }\n      } else {\n        // everything has worked as expected, let's mark\n        // the connection as alive (or confirm it)\n        this.connectionPool.markAlive(meta.connection);\n      }\n      if (ignoreStatusCode === false && result.statusCode >= 400) {\n        const error = new ResponseError(result);\n        this.emit('response', error, result);\n        callback(error, result);\n      } else {\n        // cast to boolean if the request method was HEAD\n        if (isHead === true && result.statusCode === 404) {\n          result.body = false;\n        }\n        this.emit('response', null, result);\n        callback(null, result);\n      }\n    };\n    const prepareRequest = () => {\n      this.emit('serialization', null, result);\n      const headers = Object.assign({}, this.headers, lowerCaseHeaders(options.headers));\n      if (options.opaqueId !== undefined) {\n        headers['x-opaque-id'] = this.opaqueIdPrefix !== null ? this.opaqueIdPrefix + options.opaqueId : options.opaqueId;\n      }\n\n      // handle json body\n      if (params.body != null) {\n        if (shouldSerialize(params.body) === true) {\n          try {\n            params.body = this.serializer.serialize(params.body);\n          } catch (err) {\n            this.emit('request', err, result);\n            process.nextTick(callback, err, result);\n            return transportReturn;\n          }\n        }\n        if (params.body !== '') {\n          headers['content-type'] = headers['content-type'] || (this[kApiVersioning] ? 'application/vnd.opensearch+json; compatible-with=7' : 'application/json');\n        }\n\n        // handle ndjson body\n      } else if (params.bulkBody != null) {\n        if (shouldSerialize(params.bulkBody) === true) {\n          try {\n            params.body = this.serializer.ndserialize(params.bulkBody);\n          } catch (err) {\n            this.emit('request', err, result);\n            process.nextTick(callback, err, result);\n            return transportReturn;\n          }\n        } else {\n          params.body = params.bulkBody;\n        }\n        if (params.body !== '') {\n          headers['content-type'] = headers['content-type'] || (this[kApiVersioning] ? 'application/vnd.opensearch+x-ndjson; compatible-with=7' : 'application/x-ndjson');\n        }\n      }\n      params.headers = headers;\n      // serializes the querystring\n      if (options.querystring == null) {\n        params.querystring = this.serializer.qserialize(params.querystring);\n      } else {\n        params.querystring = this.serializer.qserialize(Object.assign({}, params.querystring, options.querystring));\n      }\n      if (this._auth !== null && typeof this._auth === 'object' && 'credentials' in this._auth) {\n        params.auth = this._auth;\n      }\n\n      // handles request timeout\n      params.timeout = toMs(options.requestTimeout || this.requestTimeout);\n      if (options.asStream === true) params.asStream = true;\n      meta.request.params = params;\n      meta.request.options = options;\n\n      // handle compression\n      if (params.body !== '' && params.body != null) {\n        if (isStream(params.body) === true) {\n          if (compression === 'gzip') {\n            params.headers['content-encoding'] = compression;\n            params.body = params.body.pipe(createGzip());\n          }\n          makeRequest();\n        } else if (compression === 'gzip') {\n          gzip(params.body, (err, buffer) => {\n            /* istanbul ignore next */\n            if (err) {\n              this.emit('request', err, result);\n              return callback(err, result);\n            }\n            params.headers['content-encoding'] = compression;\n            params.headers['content-length'] = '' + Buffer.byteLength(buffer);\n            params.body = buffer;\n            makeRequest();\n          });\n        } else {\n          params.headers['content-length'] = '' + Buffer.byteLength(params.body);\n          makeRequest();\n        }\n      } else {\n        makeRequest();\n      }\n    };\n    prepareRequest();\n    return transportReturn;\n  }\n  getConnection(opts) {\n    const now = Date.now();\n    if (this._sniffEnabled === true && now > this._nextSniff) {\n      this.sniff({\n        reason: Transport.sniffReasons.SNIFF_INTERVAL,\n        requestId: opts.requestId\n      });\n    }\n    return this.connectionPool.getConnection({\n      filter: this.nodeFilter,\n      selector: this.nodeSelector,\n      requestId: opts.requestId,\n      name: this.name,\n      now\n    });\n  }\n  sniff(opts, callback = noop) {\n    if (this._isSniffing === true) return;\n    this._isSniffing = true;\n    debug('Started sniffing request');\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {\n        reason: Transport.sniffReasons.DEFAULT\n      };\n    }\n    const {\n      reason\n    } = opts;\n    const request = {\n      method: 'GET',\n      path: this.sniffEndpoint\n    };\n    this.request(request, {\n      id: opts.requestId\n    }, (err, result) => {\n      this._isSniffing = false;\n      if (this._sniffEnabled === true) {\n        this._nextSniff = Date.now() + this.sniffInterval;\n      }\n      if (err != null) {\n        debug('Sniffing errored', err);\n        result.meta.sniff = {\n          hosts: [],\n          reason\n        };\n        this.emit('sniff', err, result);\n        return callback(err);\n      }\n      debug('Sniffing ended successfully', result.body);\n      const protocol = result.meta.connection.url.protocol || /* istanbul ignore next */'http:';\n      const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol);\n      this.connectionPool.update(hosts);\n      result.meta.sniff = {\n        hosts,\n        reason\n      };\n      this.emit('sniff', null, result);\n      callback(null, hosts);\n    });\n  }\n\n  // checkCompatibleInfo validates whether the informations are compatible\n  checkCompatibleInfo() {\n    debug('Start compatible check');\n    this[kCompatibleCheck] = 1;\n    this.request({\n      method: 'GET',\n      path: '/'\n    }, (err, result) => {\n      this[kCompatibleCheck] = 3;\n      if (err) {\n        debug('compatible check failed', err);\n        if (err.statusCode === 401 || err.statusCode === 403) {\n          this[kCompatibleCheck] = 2;\n          process.emitWarning('The client is unable to verify the distribution due to security privileges on the server side. Some functionality may not be compatible if the server is running an unsupported product.');\n          compatibleCheckEmitter.emit('compatible-check', true);\n        } else {\n          this[kCompatibleCheck] = 0;\n          compatibleCheckEmitter.emit('compatible-check', false);\n        }\n      } else {\n        debug('Checking OpenSearch version', result.body, result.headers);\n        if (result.body.version == null || typeof result.body.version.number !== 'string') {\n          debug(\"Can't access OpenSearch version\");\n          return compatibleCheckEmitter.emit('compatible-check', false);\n        }\n        const distribution = result.body.version.distribution;\n        const version = result.body.version.number.split('.');\n        const major = Number(version[0]);\n\n        // support OpenSearch validation\n        if (distribution === 'opensearch') {\n          debug('Valid OpenSearch distribution');\n          this[kCompatibleCheck] = 2;\n          return compatibleCheckEmitter.emit('compatible-check', true);\n        }\n\n        // support odfe > v7 validation\n        if (major !== 7) {\n          debug('Invalid distribution');\n          return compatibleCheckEmitter.emit('compatible-check', false);\n        }\n        debug('Valid OpenSearch distribution');\n        this[kCompatibleCheck] = 2;\n        compatibleCheckEmitter.emit('compatible-check', true);\n      }\n    });\n  }\n}\nTransport.sniffReasons = {\n  SNIFF_ON_START: 'sniff-on-start',\n  SNIFF_INTERVAL: 'sniff-interval',\n  SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',\n  // TODO: find a better name\n  DEFAULT: 'default'\n};\nfunction toMs(time) {\n  if (typeof time === 'string') {\n    return ms(time);\n  }\n  return time;\n}\nfunction shouldSerialize(obj) {\n  return typeof obj !== 'string' && typeof obj.pipe !== 'function' && Buffer.isBuffer(obj) === false;\n}\nfunction isStream(obj) {\n  return obj != null && typeof obj.pipe === 'function';\n}\nfunction defaultNodeFilter(node) {\n  // avoid cluster_manager or master only nodes\n  // TODO: remove role check on master when master is not supported\n  if ((node.roles.cluster_manager === true || node.roles.master === true) && node.roles.data === false && node.roles.ingest === false) {\n    return false;\n  }\n  return true;\n}\nfunction roundRobinSelector() {\n  let current = -1;\n  return function _roundRobinSelector(connections) {\n    if (++current >= connections.length) {\n      current = 0;\n    }\n    return connections[current];\n  };\n}\nfunction randomSelector(connections) {\n  const index = Math.floor(Math.random() * connections.length);\n  return connections[index];\n}\nfunction generateRequestId() {\n  const maxInt = 2147483647;\n  let nextReqId = 0;\n  return function genReqId() {\n    return nextReqId = nextReqId + 1 & maxInt;\n  };\n}\nfunction lowerCaseHeaders(oldHeaders) {\n  if (oldHeaders == null) return oldHeaders;\n  const newHeaders = {};\n  for (const header in oldHeaders) {\n    newHeaders[header.toLowerCase()] = oldHeaders[header];\n  }\n  return newHeaders;\n}\nfunction validateMemoryPercentage(percentage) {\n  if (percentage < 0 || percentage > 1) return 1.0;\n  return percentage;\n}\nmodule.exports = Transport;\nmodule.exports.internals = {\n  defaultNodeFilter,\n  roundRobinSelector,\n  randomSelector,\n  generateRequestId,\n  lowerCaseHeaders,\n  toMs\n};","map":{"version":3,"names":["require","debug","os","gzip","unzip","createGzip","buffer","ms","EventEmitter","ConnectionError","RequestAbortedError","NoLivingConnectionsError","ResponseError","ConfigurationError","noop","compatibleCheckEmitter","clientVersion","version","userAgent","platform","release","arch","process","MAX_BUFFER_LENGTH","constants","MAX_LENGTH","MAX_STRING_LENGTH","HEAP_SIZE_LIMIT","getHeapStatistics","heap_size_limit","kCompatibleCheck","Symbol","kApiVersioning","Transport","constructor","opts","compression","emit","connectionPool","serializer","maxRetries","requestTimeout","toMs","suggestCompression","context","headers","Object","assign","lowerCaseHeaders","sniffInterval","sniffOnConnectionFault","sniffEndpoint","generateRequestId","name","opaqueIdPrefix","env","OPENSEARCH_CLIENT_APIVERSIONING","memoryCircuitBreaker","nodeFilter","defaultNodeFilter","nodeSelector","roundRobinSelector","randomSelector","_sniffEnabled","_nextSniff","Date","now","_isSniffing","_auth","auth","sniffOnStart","setTimeout","sniff","reason","sniffReasons","SNIFF_ON_START","request","params","options","callback","p","undefined","onFulfilled","onRejected","Promise","resolve","reject","err","result","meta","id","connection","attempts","aborted","body","statusCode","defineProperty","get","warning","split","isStream","bulkBody","abort","transportReturn","then","catch","finally","onFinally","makeRequest","nextTick","getConnection","requestId","onResponse","onConnectionError","markDead","SNIFF_ON_CONNECTION_FAULT","response","asStream","contentEncoding","toLowerCase","isCompressed","indexOf","contentLength","Number","destroy","shouldApplyCircuitBreaker","payload","onData","chunk","push","onEnd","removeListener","onAbort","message","Buffer","concat","onBody","Error","setEncoding","on","enabled","maxPercentage","validateMemoryPercentage","heapUsed","memoryUsage","isBuffer","toString","isHead","method","deserialize","ignoreStatusCode","Array","isArray","ignore","markAlive","error","prepareRequest","opaqueId","shouldSerialize","serialize","ndserialize","querystring","qserialize","timeout","pipe","byteLength","SNIFF_INTERVAL","filter","selector","DEFAULT","path","hosts","protocol","url","nodesToHost","nodes","update","checkCompatibleInfo","emitWarning","number","distribution","major","time","obj","node","roles","cluster_manager","master","data","ingest","current","_roundRobinSelector","connections","length","index","Math","floor","random","maxInt","nextReqId","genReqId","oldHeaders","newHeaders","header","percentage","module","exports","internals"],"sources":["C:/search/vue-search/node_modules/@opensearch-project/opensearch/lib/Transport.js"],"sourcesContent":["/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nconst debug = require('debug')('opensearch');\nconst os = require('os');\nconst { gzip, unzip, createGzip } = require('zlib');\nconst buffer = require('buffer');\nconst ms = require('ms');\nconst { EventEmitter } = require('events');\nconst {\n  ConnectionError,\n  RequestAbortedError,\n  NoLivingConnectionsError,\n  ResponseError,\n  ConfigurationError,\n} = require('./errors');\n\nconst noop = () => {};\n\nconst compatibleCheckEmitter = new EventEmitter();\nconst clientVersion = require('../package.json').version;\nconst userAgent = `opensearch-js/${clientVersion} (${os.platform()} ${os.release()}-${os.arch()}; Node.js ${\n  process.version\n})`;\nconst MAX_BUFFER_LENGTH = buffer.constants.MAX_LENGTH;\nconst MAX_STRING_LENGTH = buffer.constants.MAX_STRING_LENGTH;\nconst HEAP_SIZE_LIMIT = require('v8').getHeapStatistics().heap_size_limit;\nconst kCompatibleCheck = Symbol('compatible check');\nconst kApiVersioning = Symbol('api versioning');\n\n/** Default Transport Layer */\nclass Transport {\n  constructor(opts) {\n    if (typeof opts.compression === 'string' && opts.compression !== 'gzip') {\n      throw new ConfigurationError(`Invalid compression: '${opts.compression}'`);\n    }\n\n    this.emit = opts.emit;\n    this.connectionPool = opts.connectionPool;\n    this.serializer = opts.serializer;\n    this.maxRetries = opts.maxRetries;\n    this.requestTimeout = toMs(opts.requestTimeout);\n    this.suggestCompression = opts.suggestCompression === true;\n    this.compression = opts.compression || false;\n    this.context = opts.context || null;\n    this.headers = Object.assign(\n      {},\n      { 'user-agent': userAgent },\n      opts.suggestCompression === true ? { 'accept-encoding': 'gzip,deflate' } : null,\n      lowerCaseHeaders(opts.headers)\n    );\n    this.sniffInterval = opts.sniffInterval;\n    this.sniffOnConnectionFault = opts.sniffOnConnectionFault;\n    this.sniffEndpoint = opts.sniffEndpoint;\n    this.generateRequestId = opts.generateRequestId || generateRequestId();\n    this.name = opts.name;\n    this.opaqueIdPrefix = opts.opaqueIdPrefix;\n    this[kCompatibleCheck] = 0; // 0 = to be checked, 1 = checking, 2 = checked-ok, 3 checked-notok\n    this[kApiVersioning] = process.env.OPENSEARCH_CLIENT_APIVERSIONING === 'true';\n    this.memoryCircuitBreaker = opts.memoryCircuitBreaker;\n\n    this.nodeFilter = opts.nodeFilter || defaultNodeFilter;\n    if (typeof opts.nodeSelector === 'function') {\n      this.nodeSelector = opts.nodeSelector;\n    } else if (opts.nodeSelector === 'round-robin') {\n      this.nodeSelector = roundRobinSelector();\n    } else if (opts.nodeSelector === 'random') {\n      this.nodeSelector = randomSelector;\n    } else {\n      this.nodeSelector = roundRobinSelector();\n    }\n\n    this._sniffEnabled = typeof this.sniffInterval === 'number';\n    this._nextSniff = this._sniffEnabled ? Date.now() + this.sniffInterval : 0;\n    this._isSniffing = false;\n    this._auth = opts.auth;\n\n    if (opts.sniffOnStart === true) {\n      // timer needed otherwise it will clash\n      // with the compatible check testing\n      setTimeout(() => {\n        this.sniff({ reason: Transport.sniffReasons.SNIFF_ON_START });\n      }, 10);\n    }\n  }\n\n  /**\n   * @param {Object} params\n   * @param {string} params.method - HTTP Method (e.g. HEAD, GET, POST...)\n   * @param {string} params.path - Relative URL path\n   * @param {Object | string} [params.body] - Body of a standard request.\n   * @param {Object[] | string} [params.bulkBody] - Body of a bulk request.\n   * @param {Object[] | string} [params.querystring] - Querystring params.\n   *\n   * @param {Object} options\n   * @param {number} [options.id] - Request ID\n   * @param {Object} [options.context] - Object used for observability\n   * @param {number} [options.maxRetries] - Max number of retries\n   * @param {false | 'gzip'} [options.compression] - Request body compression, if any\n   * @param {boolean} [options.asStream] - Whether to emit the response as stream\n   * @param {number[]} [options.ignore] - Response's Error Status Codes to ignore\n   * @param {Object} [options.headers] - Request headers\n   * @param {Object | string} [options.querystring] - Request's query string\n   * @param {number} [options.requestTimeout] - Max request timeout in milliseconds\n   *\n   * @param {function} callback - Callback that handles errors and response\n   */\n  request(params, options, callback) {\n    options = options || {};\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    let p = null;\n\n    // promises support\n    if (callback === undefined) {\n      let onFulfilled = null;\n      let onRejected = null;\n      p = new Promise((resolve, reject) => {\n        onFulfilled = resolve;\n        onRejected = reject;\n      });\n      callback = function callback(err, result) {\n        err ? onRejected(err) : onFulfilled(result);\n      };\n    }\n\n    const meta = {\n      context: null,\n      request: {\n        params: null,\n        options: null,\n        id: options.id || this.generateRequestId(params, options),\n      },\n      name: this.name,\n      connection: null,\n      attempts: 0,\n      aborted: false,\n    };\n\n    if (this.context != null && options.context != null) {\n      meta.context = Object.assign({}, this.context, options.context);\n    } else if (this.context != null) {\n      meta.context = this.context;\n    } else if (options.context != null) {\n      meta.context = options.context;\n    }\n\n    const result = {\n      body: null,\n      statusCode: null,\n      headers: null,\n      meta,\n    };\n\n    Object.defineProperty(result, 'warnings', {\n      get() {\n        return this.headers && this.headers.warning\n          ? this.headers.warning.split(/(?!\\B\"[^\"]*),(?![^\"]*\"\\B)/)\n          : null;\n      },\n    });\n\n    // We should not retry if we are sending a stream body, because we should store in memory\n    // a copy of the stream to be able to send it again, but since we don't know in advance\n    // the size of the stream, we risk to take too much memory.\n    // Furthermore, copying everytime the stream is very a expensive operation.\n    const maxRetries =\n      isStream(params.body) || isStream(params.bulkBody)\n        ? 0\n        : typeof options.maxRetries === 'number'\n          ? options.maxRetries\n          : this.maxRetries;\n    const compression = options.compression !== undefined ? options.compression : this.compression;\n    let request = { abort: noop };\n    const transportReturn = {\n      then(onFulfilled, onRejected) {\n        if (p != null) {\n          return p.then(onFulfilled, onRejected);\n        }\n      },\n      catch(onRejected) {\n        if (p != null) {\n          return p.catch(onRejected);\n        }\n      },\n      abort() {\n        meta.aborted = true;\n        request.abort();\n        debug('Aborting request', params);\n        return this;\n      },\n      finally(onFinally) {\n        if (p != null) {\n          return p.finally(onFinally);\n        }\n      },\n    };\n\n    const makeRequest = () => {\n      if (meta.aborted === true) {\n        return process.nextTick(callback, new RequestAbortedError(), result);\n      }\n      meta.connection = this.getConnection({ requestId: meta.request.id });\n      if (meta.connection == null) {\n        return process.nextTick(callback, new NoLivingConnectionsError(), result);\n      }\n      this.emit('request', null, result);\n      // perform the actual http request\n      request = meta.connection.request(params, onResponse);\n    };\n\n    const onConnectionError = (err) => {\n      if (err.name !== 'RequestAbortedError') {\n        // if there is an error in the connection\n        // let's mark the connection as dead\n        this.connectionPool.markDead(meta.connection);\n\n        if (this.sniffOnConnectionFault === true) {\n          this.sniff({\n            reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,\n            requestId: meta.request.id,\n          });\n        }\n\n        // retry logic\n        if (meta.attempts < maxRetries) {\n          meta.attempts++;\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n          makeRequest();\n          return;\n        }\n      }\n\n      err.meta = result;\n      this.emit('response', err, result);\n      return callback(err, result);\n    };\n\n    const onResponse = (err, response) => {\n      if (err !== null) {\n        return onConnectionError(err);\n      }\n\n      result.statusCode = response.statusCode;\n      result.headers = response.headers;\n\n      if (options.asStream === true) {\n        result.body = response;\n        this.emit('response', null, result);\n        callback(null, result);\n        return;\n      }\n\n      const contentEncoding = (result.headers['content-encoding'] || '').toLowerCase();\n      const isCompressed =\n        contentEncoding.indexOf('gzip') > -1 || contentEncoding.indexOf('deflate') > -1;\n      /* istanbul ignore else */\n      if (result.headers['content-length'] !== undefined) {\n        const contentLength = Number(result.headers['content-length']);\n        // nodeJS data type limit check\n        if (isCompressed && contentLength > MAX_BUFFER_LENGTH) {\n          response.destroy();\n          return onConnectionError(\n            new RequestAbortedError(\n              `The content length (${contentLength}) is bigger than the maximum allowed buffer (${MAX_BUFFER_LENGTH})`,\n              result\n            )\n          );\n        } else if (contentLength > MAX_STRING_LENGTH) {\n          response.destroy();\n          return onConnectionError(\n            new RequestAbortedError(\n              `The content length (${contentLength}) is bigger than the maximum allowed string (${MAX_STRING_LENGTH})`,\n              result\n            )\n          );\n        } else if (shouldApplyCircuitBreaker(contentLength)) {\n          // Abort this response to avoid OOM crash of dashboards.\n          response.destroy();\n          return onConnectionError(\n            new RequestAbortedError(\n              `The content length (${contentLength}) is bigger than the maximum allowed heap memory limit.`,\n              result\n            )\n          );\n        }\n      }\n      // if the response is compressed, we must handle it\n      // as buffer for allowing decompression later\n      let payload = isCompressed ? [] : '';\n      const onData = isCompressed\n        ? (chunk) => {\n            payload.push(chunk);\n          }\n        : (chunk) => {\n            payload += chunk;\n          };\n      const onEnd = (err) => {\n        response.removeListener('data', onData);\n        response.removeListener('end', onEnd);\n        response.removeListener('error', onEnd);\n        response.removeListener('aborted', onAbort);\n\n        if (err) {\n          return onConnectionError(new ConnectionError(err.message));\n        }\n\n        if (isCompressed) {\n          unzip(Buffer.concat(payload), onBody);\n        } else {\n          onBody(null, payload);\n        }\n      };\n\n      const onAbort = () => {\n        response.destroy();\n        onEnd(new Error('Response aborted while reading the body'));\n      };\n\n      if (!isCompressed) {\n        response.setEncoding('utf8');\n      }\n\n      this.emit('deserialization', null, result);\n      response.on('data', onData);\n      response.on('error', onEnd);\n      response.on('end', onEnd);\n      response.on('aborted', onAbort);\n    };\n    // Helper function to check if memory circuit breaker enabled and the response payload is too large to fit into available heap memory.\n    const shouldApplyCircuitBreaker = (contentLength) => {\n      if (!this.memoryCircuitBreaker || !this.memoryCircuitBreaker.enabled) return false;\n      const maxPercentage = validateMemoryPercentage(this.memoryCircuitBreaker.maxPercentage);\n      const heapUsed = process.memoryUsage().heapUsed;\n      return contentLength + heapUsed > HEAP_SIZE_LIMIT * maxPercentage;\n    };\n\n    const onBody = (err, payload) => {\n      if (err) {\n        this.emit('response', err, result);\n        return callback(err, result);\n      }\n      if (Buffer.isBuffer(payload)) {\n        payload = payload.toString();\n      }\n      const isHead = params.method === 'HEAD';\n      // we should attempt the payload deserialization only if:\n      //    - a `content-type` is defined and is equal to `application/json`\n      //    - the request is not a HEAD request\n      //    - the payload is not an empty string\n      if (\n        result.headers['content-type'] !== undefined &&\n        (result.headers['content-type'].indexOf('application/json') > -1 ||\n          result.headers['content-type'].indexOf('application/vnd.opensearch+json') > -1) &&\n        isHead === false &&\n        payload !== ''\n      ) {\n        try {\n          result.body = this.serializer.deserialize(payload);\n        } catch (err) {\n          this.emit('response', err, result);\n          return callback(err, result);\n        }\n      } else {\n        // cast to boolean if the request method was HEAD and there was no error\n        result.body = isHead === true && result.statusCode < 400 ? true : payload;\n      }\n\n      // we should ignore the statusCode if the user has configured the `ignore` field with\n      // the statusCode we just got or if the request method is HEAD and the statusCode is 404\n      const ignoreStatusCode =\n        (Array.isArray(options.ignore) && options.ignore.indexOf(result.statusCode) > -1) ||\n        (isHead === true && result.statusCode === 404);\n\n      if (\n        ignoreStatusCode === false &&\n        (result.statusCode === 502 || result.statusCode === 503 || result.statusCode === 504)\n      ) {\n        // if the statusCode is 502/3/4 we should run our retry strategy\n        // and mark the connection as dead\n        this.connectionPool.markDead(meta.connection);\n        // retry logic (we should not retry on \"429 - Too Many Requests\")\n        if (meta.attempts < maxRetries && result.statusCode !== 429) {\n          meta.attempts++;\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n          makeRequest();\n          return;\n        }\n      } else {\n        // everything has worked as expected, let's mark\n        // the connection as alive (or confirm it)\n        this.connectionPool.markAlive(meta.connection);\n      }\n\n      if (ignoreStatusCode === false && result.statusCode >= 400) {\n        const error = new ResponseError(result);\n        this.emit('response', error, result);\n        callback(error, result);\n      } else {\n        // cast to boolean if the request method was HEAD\n        if (isHead === true && result.statusCode === 404) {\n          result.body = false;\n        }\n        this.emit('response', null, result);\n        callback(null, result);\n      }\n    };\n\n    const prepareRequest = () => {\n      this.emit('serialization', null, result);\n      const headers = Object.assign({}, this.headers, lowerCaseHeaders(options.headers));\n\n      if (options.opaqueId !== undefined) {\n        headers['x-opaque-id'] =\n          this.opaqueIdPrefix !== null ? this.opaqueIdPrefix + options.opaqueId : options.opaqueId;\n      }\n\n      // handle json body\n      if (params.body != null) {\n        if (shouldSerialize(params.body) === true) {\n          try {\n            params.body = this.serializer.serialize(params.body);\n          } catch (err) {\n            this.emit('request', err, result);\n            process.nextTick(callback, err, result);\n            return transportReturn;\n          }\n        }\n\n        if (params.body !== '') {\n          headers['content-type'] =\n            headers['content-type'] ||\n            (this[kApiVersioning]\n              ? 'application/vnd.opensearch+json; compatible-with=7'\n              : 'application/json');\n        }\n\n        // handle ndjson body\n      } else if (params.bulkBody != null) {\n        if (shouldSerialize(params.bulkBody) === true) {\n          try {\n            params.body = this.serializer.ndserialize(params.bulkBody);\n          } catch (err) {\n            this.emit('request', err, result);\n            process.nextTick(callback, err, result);\n            return transportReturn;\n          }\n        } else {\n          params.body = params.bulkBody;\n        }\n        if (params.body !== '') {\n          headers['content-type'] =\n            headers['content-type'] ||\n            (this[kApiVersioning]\n              ? 'application/vnd.opensearch+x-ndjson; compatible-with=7'\n              : 'application/x-ndjson');\n        }\n      }\n\n      params.headers = headers;\n      // serializes the querystring\n      if (options.querystring == null) {\n        params.querystring = this.serializer.qserialize(params.querystring);\n      } else {\n        params.querystring = this.serializer.qserialize(\n          Object.assign({}, params.querystring, options.querystring)\n        );\n      }\n      if (this._auth !== null && typeof this._auth === 'object' && 'credentials' in this._auth) {\n        params.auth = this._auth;\n      }\n\n      // handles request timeout\n      params.timeout = toMs(options.requestTimeout || this.requestTimeout);\n      if (options.asStream === true) params.asStream = true;\n      meta.request.params = params;\n      meta.request.options = options;\n\n      // handle compression\n      if (params.body !== '' && params.body != null) {\n        if (isStream(params.body) === true) {\n          if (compression === 'gzip') {\n            params.headers['content-encoding'] = compression;\n            params.body = params.body.pipe(createGzip());\n          }\n          makeRequest();\n        } else if (compression === 'gzip') {\n          gzip(params.body, (err, buffer) => {\n            /* istanbul ignore next */\n            if (err) {\n              this.emit('request', err, result);\n              return callback(err, result);\n            }\n            params.headers['content-encoding'] = compression;\n            params.headers['content-length'] = '' + Buffer.byteLength(buffer);\n            params.body = buffer;\n            makeRequest();\n          });\n        } else {\n          params.headers['content-length'] = '' + Buffer.byteLength(params.body);\n          makeRequest();\n        }\n      } else {\n        makeRequest();\n      }\n    };\n\n    prepareRequest();\n\n    return transportReturn;\n  }\n\n  getConnection(opts) {\n    const now = Date.now();\n    if (this._sniffEnabled === true && now > this._nextSniff) {\n      this.sniff({ reason: Transport.sniffReasons.SNIFF_INTERVAL, requestId: opts.requestId });\n    }\n    return this.connectionPool.getConnection({\n      filter: this.nodeFilter,\n      selector: this.nodeSelector,\n      requestId: opts.requestId,\n      name: this.name,\n      now,\n    });\n  }\n\n  sniff(opts, callback = noop) {\n    if (this._isSniffing === true) return;\n    this._isSniffing = true;\n    debug('Started sniffing request');\n\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = { reason: Transport.sniffReasons.DEFAULT };\n    }\n\n    const { reason } = opts;\n\n    const request = {\n      method: 'GET',\n      path: this.sniffEndpoint,\n    };\n\n    this.request(request, { id: opts.requestId }, (err, result) => {\n      this._isSniffing = false;\n      if (this._sniffEnabled === true) {\n        this._nextSniff = Date.now() + this.sniffInterval;\n      }\n\n      if (err != null) {\n        debug('Sniffing errored', err);\n        result.meta.sniff = { hosts: [], reason };\n        this.emit('sniff', err, result);\n        return callback(err);\n      }\n\n      debug('Sniffing ended successfully', result.body);\n      const protocol = result.meta.connection.url.protocol || /* istanbul ignore next */ 'http:';\n      const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol);\n      this.connectionPool.update(hosts);\n\n      result.meta.sniff = { hosts, reason };\n      this.emit('sniff', null, result);\n      callback(null, hosts);\n    });\n  }\n\n  // checkCompatibleInfo validates whether the informations are compatible\n  checkCompatibleInfo() {\n    debug('Start compatible check');\n    this[kCompatibleCheck] = 1;\n    this.request(\n      {\n        method: 'GET',\n        path: '/',\n      },\n      (err, result) => {\n        this[kCompatibleCheck] = 3;\n        if (err) {\n          debug('compatible check failed', err);\n          if (err.statusCode === 401 || err.statusCode === 403) {\n            this[kCompatibleCheck] = 2;\n            process.emitWarning(\n              'The client is unable to verify the distribution due to security privileges on the server side. Some functionality may not be compatible if the server is running an unsupported product.'\n            );\n            compatibleCheckEmitter.emit('compatible-check', true);\n          } else {\n            this[kCompatibleCheck] = 0;\n            compatibleCheckEmitter.emit('compatible-check', false);\n          }\n        } else {\n          debug('Checking OpenSearch version', result.body, result.headers);\n          if (result.body.version == null || typeof result.body.version.number !== 'string') {\n            debug(\"Can't access OpenSearch version\");\n            return compatibleCheckEmitter.emit('compatible-check', false);\n          }\n\n          const distribution = result.body.version.distribution;\n          const version = result.body.version.number.split('.');\n          const major = Number(version[0]);\n\n          // support OpenSearch validation\n          if (distribution === 'opensearch') {\n            debug('Valid OpenSearch distribution');\n            this[kCompatibleCheck] = 2;\n            return compatibleCheckEmitter.emit('compatible-check', true);\n          }\n\n          // support odfe > v7 validation\n          if (major !== 7) {\n            debug('Invalid distribution');\n            return compatibleCheckEmitter.emit('compatible-check', false);\n          }\n\n          debug('Valid OpenSearch distribution');\n          this[kCompatibleCheck] = 2;\n          compatibleCheckEmitter.emit('compatible-check', true);\n        }\n      }\n    );\n  }\n}\n\nTransport.sniffReasons = {\n  SNIFF_ON_START: 'sniff-on-start',\n  SNIFF_INTERVAL: 'sniff-interval',\n  SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',\n  // TODO: find a better name\n  DEFAULT: 'default',\n};\n\nfunction toMs(time) {\n  if (typeof time === 'string') {\n    return ms(time);\n  }\n  return time;\n}\n\nfunction shouldSerialize(obj) {\n  return (\n    typeof obj !== 'string' && typeof obj.pipe !== 'function' && Buffer.isBuffer(obj) === false\n  );\n}\n\nfunction isStream(obj) {\n  return obj != null && typeof obj.pipe === 'function';\n}\n\nfunction defaultNodeFilter(node) {\n  // avoid cluster_manager or master only nodes\n  // TODO: remove role check on master when master is not supported\n  if (\n    (node.roles.cluster_manager === true || node.roles.master === true) &&\n    node.roles.data === false &&\n    node.roles.ingest === false\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction roundRobinSelector() {\n  let current = -1;\n  return function _roundRobinSelector(connections) {\n    if (++current >= connections.length) {\n      current = 0;\n    }\n    return connections[current];\n  };\n}\n\nfunction randomSelector(connections) {\n  const index = Math.floor(Math.random() * connections.length);\n  return connections[index];\n}\n\nfunction generateRequestId() {\n  const maxInt = 2147483647;\n  let nextReqId = 0;\n  return function genReqId() {\n    return (nextReqId = (nextReqId + 1) & maxInt);\n  };\n}\n\nfunction lowerCaseHeaders(oldHeaders) {\n  if (oldHeaders == null) return oldHeaders;\n  const newHeaders = {};\n  for (const header in oldHeaders) {\n    newHeaders[header.toLowerCase()] = oldHeaders[header];\n  }\n  return newHeaders;\n}\n\nfunction validateMemoryPercentage(percentage) {\n  if (percentage < 0 || percentage > 1) return 1.0;\n  return percentage;\n}\n\nmodule.exports = Transport;\nmodule.exports.internals = {\n  defaultNodeFilter,\n  roundRobinSelector,\n  randomSelector,\n  generateRequestId,\n  lowerCaseHeaders,\n  toMs,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}