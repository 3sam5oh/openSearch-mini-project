{"ast":null,"code":"/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\n/* eslint camelcase: 0 */\n/* eslint no-unused-vars: 0 */\n\n/** @namespace API-Nodes */\nconst {\n  handleError,\n  snakeCaseKeys,\n  normalizeArguments,\n  kConfigurationError\n} = require('../utils');\nconst acceptedQuerystring = ['pretty', 'human', 'error_trace', 'source', 'filter_path', 'interval', 'snapshots', 'threads', 'ignore_idle_threads', 'type', 'timeout', 'flat_settings', 'completion_fields', 'fielddata_fields', 'fields', 'groups', 'level', 'types', 'include_segment_file_sizes', 'include_unloaded_segments'];\nconst snakeCase = {\n  errorTrace: 'error_trace',\n  filterPath: 'filter_path',\n  ignoreIdleThreads: 'ignore_idle_threads',\n  flatSettings: 'flat_settings',\n  completionFields: 'completion_fields',\n  fielddataFields: 'fielddata_fields',\n  includeSegmentFileSizes: 'include_segment_file_sizes',\n  includeUnloadedSegments: 'include_unloaded_segments'\n};\nfunction NodesApi(transport, ConfigurationError) {\n  this.transport = transport;\n  this[kConfigurationError] = ConfigurationError;\n}\nNodesApi.prototype.clearMeteringArchive = function nodesClearMeteringArchiveApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  // check required parameters\n  if (params.node_id == null && params.nodeId == null) {\n    const err = new this[kConfigurationError]('Missing required parameter: node_id or nodeId');\n    return handleError(err, callback);\n  }\n  if (params.max_archive_version == null && params.maxArchiveVersion == null) {\n    const err = new this[kConfigurationError]('Missing required parameter: max_archive_version or maxArchiveVersion');\n    return handleError(err, callback);\n  }\n\n  // check required url components\n  if ((params.max_archive_version != null || params.maxArchiveVersion != null) && params.node_id == null && params.nodeId == null) {\n    const err = new this[kConfigurationError]('Missing required parameter of the url: node_id');\n    return handleError(err, callback);\n  }\n  let {\n    method,\n    body,\n    nodeId,\n    node_id,\n    maxArchiveVersion,\n    max_archive_version,\n    ...querystring\n  } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n  let path = '';\n  if (method == null) method = 'DELETE';\n  path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + '_repositories_metering' + '/' + encodeURIComponent(max_archive_version || maxArchiveVersion);\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: body || '',\n    querystring\n  };\n  return this.transport.request(request, options, callback);\n};\nNodesApi.prototype.getMeteringInfo = function nodesGetMeteringInfoApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  // check required parameters\n  if (params.node_id == null && params.nodeId == null) {\n    const err = new this[kConfigurationError]('Missing required parameter: node_id or nodeId');\n    return handleError(err, callback);\n  }\n  let {\n    method,\n    body,\n    nodeId,\n    node_id,\n    ...querystring\n  } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n  let path = '';\n  if (method == null) method = 'GET';\n  path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + '_repositories_metering';\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring\n  };\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns information about hot threads on each node in the cluster.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-hot-threads/ OpenSearch - Nodes Hot Threads}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.interval] - The interval for the second sampling of threads\n * @param {number} [params.snapshots] - Number of samples of thread stacktrace (default: 10)\n * @param {number} [params.threads] - Specify the number of threads to provide information for (default: 3)\n * @param {boolean} [params.ignore_idle_threads] - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)\n * @param {string} [params.type] - The type to sample (default: cpu) (options: cpu, wait, block)\n * @param {string} [params.timeout] - Explicit operation timeout\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.hotThreads = function nodesHotThreadsApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n  let {\n    method,\n    body,\n    nodeId,\n    node_id,\n    ...querystring\n  } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n  let path = '';\n  if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'hot_threads';\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_cluster' + '/' + 'nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'hotthreads';\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'hotthreads';\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_cluster' + '/' + 'nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'hot_threads';\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'hot_threads';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring\n  };\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns information about hot threads on each node in the cluster.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-info/ OpenSearch - Nodes Info}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.metric] - A comma-separated list of metrics you wish returned. Leave empty to return all. (options: settings, os, process, jvm, thread_pool, transport, http, plugins, ingest)\n * @param {boolean} [params.flat_settings] - Return settings in flat format (default: false)\n * @param {string} [params.timeout] - Explicit operation timeout\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.info = function nodesInfoApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n  let {\n    method,\n    body,\n    nodeId,\n    node_id,\n    metric,\n    ...querystring\n  } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n  let path = '';\n  if ((node_id || nodeId) != null && metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + encodeURIComponent(metric);\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId);\n  } else if (metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(metric);\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring\n  };\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Reloads secure settings.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-reload-secure/ OpenSearch - Nodes Reload Security Settings}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.\n * @param {string} [params.timeout] - Explicit operation timeout\n * @param {Object} [params.body] - An object containing the password for the opensearch keystore\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.reloadSecureSettings = function nodesReloadSecureSettingsApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n  let {\n    method,\n    body,\n    nodeId,\n    node_id,\n    ...querystring\n  } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n  let path = '';\n  if ((node_id || nodeId) != null) {\n    if (method == null) method = 'POST';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'reload_secure_settings';\n  } else {\n    if (method == null) method = 'POST';\n    path = '/' + '_nodes' + '/' + 'reload_secure_settings';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: body || '',\n    querystring\n  };\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns statistical information about nodes in the cluster.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-stats/ OpenSearch - Nodes Stats}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.metric] - Limit the information returned to the specified metrics (options: _all, breaker, fs, http, indices, jvm, os, process, thread_pool, transport, discovery, indexing_pressure)\n * @param {string} [params.index_metric] - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified. (options: _all, completion, docs, fielddata, query_cache, flush, get, indexing, merge, request_cache, refresh, search, segments, store, warmer, suggest)\n * @param {string} [params.completion_fields] - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)\n * @param {string} [params.fielddata_fields] - A comma-separated list of fields for `fielddata` index metric (supports wildcards)\n * @param {string} [params.fields] - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)\n * @param {boolean} [params.groups] - A comma-separated list of search groups for `search` index metric\n * @param {string} [params.level] - Return indices stats aggregated at index, node or shard level (options: indices, node, shards)\n * @param {string} [params.types] - A comma-separated list of document types for the `indexing` index metric\n * @param {string} [params.timeout] - Explicit operation timeout\n * @param {boolean} [params.include_segment_file_sizes] - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)\n * @param {boolean} [params.include_unloaded_segments] - If set to true segment stats will include stats for segments that are not currently loaded into memory\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.stats = function nodesStatsApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n  let {\n    method,\n    body,\n    nodeId,\n    node_id,\n    metric,\n    indexMetric,\n    index_metric,\n    ...querystring\n  } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n  let path = '';\n  if ((node_id || nodeId) != null && metric != null && (index_metric || indexMetric) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'stats' + '/' + encodeURIComponent(metric) + '/' + encodeURIComponent(index_metric || indexMetric);\n  } else if ((node_id || nodeId) != null && metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'stats' + '/' + encodeURIComponent(metric);\n  } else if (metric != null && (index_metric || indexMetric) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'stats' + '/' + encodeURIComponent(metric) + '/' + encodeURIComponent(index_metric || indexMetric);\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'stats';\n  } else if (metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'stats' + '/' + encodeURIComponent(metric);\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'stats';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring\n  };\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns low-level information about REST actions usage on nodes.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-usage/ OpenSearch - Nodes Usage}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.metric] - Limit the information returned to the specified metrics (options: _all, rest_actions)\n * @param {string} [params.timeout] - Explicit operation timeout\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.usage = function nodesUsageApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n  let {\n    method,\n    body,\n    nodeId,\n    node_id,\n    metric,\n    ...querystring\n  } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n  let path = '';\n  if ((node_id || nodeId) != null && metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'usage' + '/' + encodeURIComponent(metric);\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'usage';\n  } else if (metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'usage' + '/' + encodeURIComponent(metric);\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'usage';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring\n  };\n  return this.transport.request(request, options, callback);\n};\nObject.defineProperties(NodesApi.prototype, {\n  clear_metering_archive: {\n    get() {\n      return this.clearMeteringArchive;\n    }\n  },\n  get_metering_info: {\n    get() {\n      return this.getMeteringInfo;\n    }\n  },\n  hot_threads: {\n    get() {\n      return this.hotThreads;\n    }\n  },\n  reload_secure_settings: {\n    get() {\n      return this.reloadSecureSettings;\n    }\n  }\n});\nmodule.exports = NodesApi;","map":{"version":3,"names":["handleError","snakeCaseKeys","normalizeArguments","kConfigurationError","require","acceptedQuerystring","snakeCase","errorTrace","filterPath","ignoreIdleThreads","flatSettings","completionFields","fielddataFields","includeSegmentFileSizes","includeUnloadedSegments","NodesApi","transport","ConfigurationError","prototype","clearMeteringArchive","nodesClearMeteringArchiveApi","params","options","callback","node_id","nodeId","err","max_archive_version","maxArchiveVersion","method","body","querystring","path","encodeURIComponent","request","getMeteringInfo","nodesGetMeteringInfoApi","hotThreads","nodesHotThreadsApi","info","nodesInfoApi","metric","reloadSecureSettings","nodesReloadSecureSettingsApi","stats","nodesStatsApi","indexMetric","index_metric","usage","nodesUsageApi","Object","defineProperties","clear_metering_archive","get","get_metering_info","hot_threads","reload_secure_settings","module","exports"],"sources":["C:/search/vue-search/node_modules/@opensearch-project/opensearch/api/api/nodes.js"],"sourcesContent":["/*\n * Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\n/* eslint camelcase: 0 */\n/* eslint no-unused-vars: 0 */\n\n/** @namespace API-Nodes */\n\nconst { handleError, snakeCaseKeys, normalizeArguments, kConfigurationError } = require('../utils');\nconst acceptedQuerystring = [\n  'pretty',\n  'human',\n  'error_trace',\n  'source',\n  'filter_path',\n  'interval',\n  'snapshots',\n  'threads',\n  'ignore_idle_threads',\n  'type',\n  'timeout',\n  'flat_settings',\n  'completion_fields',\n  'fielddata_fields',\n  'fields',\n  'groups',\n  'level',\n  'types',\n  'include_segment_file_sizes',\n  'include_unloaded_segments',\n];\nconst snakeCase = {\n  errorTrace: 'error_trace',\n  filterPath: 'filter_path',\n  ignoreIdleThreads: 'ignore_idle_threads',\n  flatSettings: 'flat_settings',\n  completionFields: 'completion_fields',\n  fielddataFields: 'fielddata_fields',\n  includeSegmentFileSizes: 'include_segment_file_sizes',\n  includeUnloadedSegments: 'include_unloaded_segments',\n};\n\nfunction NodesApi(transport, ConfigurationError) {\n  this.transport = transport;\n  this[kConfigurationError] = ConfigurationError;\n}\n\nNodesApi.prototype.clearMeteringArchive = function nodesClearMeteringArchiveApi(\n  params,\n  options,\n  callback\n) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  // check required parameters\n  if (params.node_id == null && params.nodeId == null) {\n    const err = new this[kConfigurationError]('Missing required parameter: node_id or nodeId');\n    return handleError(err, callback);\n  }\n  if (params.max_archive_version == null && params.maxArchiveVersion == null) {\n    const err = new this[kConfigurationError](\n      'Missing required parameter: max_archive_version or maxArchiveVersion'\n    );\n    return handleError(err, callback);\n  }\n\n  // check required url components\n  if (\n    (params.max_archive_version != null || params.maxArchiveVersion != null) &&\n    params.node_id == null &&\n    params.nodeId == null\n  ) {\n    const err = new this[kConfigurationError]('Missing required parameter of the url: node_id');\n    return handleError(err, callback);\n  }\n\n  let { method, body, nodeId, node_id, maxArchiveVersion, max_archive_version, ...querystring } =\n    params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n\n  let path = '';\n  if (method == null) method = 'DELETE';\n  path =\n    '/' +\n    '_nodes' +\n    '/' +\n    encodeURIComponent(node_id || nodeId) +\n    '/' +\n    '_repositories_metering' +\n    '/' +\n    encodeURIComponent(max_archive_version || maxArchiveVersion);\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: body || '',\n    querystring,\n  };\n\n  return this.transport.request(request, options, callback);\n};\n\nNodesApi.prototype.getMeteringInfo = function nodesGetMeteringInfoApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  // check required parameters\n  if (params.node_id == null && params.nodeId == null) {\n    const err = new this[kConfigurationError]('Missing required parameter: node_id or nodeId');\n    return handleError(err, callback);\n  }\n\n  let { method, body, nodeId, node_id, ...querystring } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n\n  let path = '';\n  if (method == null) method = 'GET';\n  path =\n    '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + '_repositories_metering';\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring,\n  };\n\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns information about hot threads on each node in the cluster.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-hot-threads/ OpenSearch - Nodes Hot Threads}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.interval] - The interval for the second sampling of threads\n * @param {number} [params.snapshots] - Number of samples of thread stacktrace (default: 10)\n * @param {number} [params.threads] - Specify the number of threads to provide information for (default: 3)\n * @param {boolean} [params.ignore_idle_threads] - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)\n * @param {string} [params.type] - The type to sample (default: cpu) (options: cpu, wait, block)\n * @param {string} [params.timeout] - Explicit operation timeout\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.hotThreads = function nodesHotThreadsApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  let { method, body, nodeId, node_id, ...querystring } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n\n  let path = '';\n  if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'hot_threads';\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path =\n      '/' +\n      '_cluster' +\n      '/' +\n      'nodes' +\n      '/' +\n      encodeURIComponent(node_id || nodeId) +\n      '/' +\n      'hotthreads';\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'hotthreads';\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path =\n      '/' +\n      '_cluster' +\n      '/' +\n      'nodes' +\n      '/' +\n      encodeURIComponent(node_id || nodeId) +\n      '/' +\n      'hot_threads';\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'hot_threads';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring,\n  };\n\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns information about hot threads on each node in the cluster.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-info/ OpenSearch - Nodes Info}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.metric] - A comma-separated list of metrics you wish returned. Leave empty to return all. (options: settings, os, process, jvm, thread_pool, transport, http, plugins, ingest)\n * @param {boolean} [params.flat_settings] - Return settings in flat format (default: false)\n * @param {string} [params.timeout] - Explicit operation timeout\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.info = function nodesInfoApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  let { method, body, nodeId, node_id, metric, ...querystring } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n\n  let path = '';\n  if ((node_id || nodeId) != null && metric != null) {\n    if (method == null) method = 'GET';\n    path =\n      '/' +\n      '_nodes' +\n      '/' +\n      encodeURIComponent(node_id || nodeId) +\n      '/' +\n      encodeURIComponent(metric);\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId);\n  } else if (metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(metric);\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring,\n  };\n\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Reloads secure settings.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-reload-secure/ OpenSearch - Nodes Reload Security Settings}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.\n * @param {string} [params.timeout] - Explicit operation timeout\n * @param {Object} [params.body] - An object containing the password for the opensearch keystore\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.reloadSecureSettings = function nodesReloadSecureSettingsApi(\n  params,\n  options,\n  callback\n) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  let { method, body, nodeId, node_id, ...querystring } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n\n  let path = '';\n  if ((node_id || nodeId) != null) {\n    if (method == null) method = 'POST';\n    path =\n      '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'reload_secure_settings';\n  } else {\n    if (method == null) method = 'POST';\n    path = '/' + '_nodes' + '/' + 'reload_secure_settings';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: body || '',\n    querystring,\n  };\n\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns statistical information about nodes in the cluster.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-stats/ OpenSearch - Nodes Stats}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.metric] - Limit the information returned to the specified metrics (options: _all, breaker, fs, http, indices, jvm, os, process, thread_pool, transport, discovery, indexing_pressure)\n * @param {string} [params.index_metric] - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified. (options: _all, completion, docs, fielddata, query_cache, flush, get, indexing, merge, request_cache, refresh, search, segments, store, warmer, suggest)\n * @param {string} [params.completion_fields] - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)\n * @param {string} [params.fielddata_fields] - A comma-separated list of fields for `fielddata` index metric (supports wildcards)\n * @param {string} [params.fields] - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)\n * @param {boolean} [params.groups] - A comma-separated list of search groups for `search` index metric\n * @param {string} [params.level] - Return indices stats aggregated at index, node or shard level (options: indices, node, shards)\n * @param {string} [params.types] - A comma-separated list of document types for the `indexing` index metric\n * @param {string} [params.timeout] - Explicit operation timeout\n * @param {boolean} [params.include_segment_file_sizes] - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)\n * @param {boolean} [params.include_unloaded_segments] - If set to true segment stats will include stats for segments that are not currently loaded into memory\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.stats = function nodesStatsApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  let { method, body, nodeId, node_id, metric, indexMetric, index_metric, ...querystring } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n\n  let path = '';\n  if ((node_id || nodeId) != null && metric != null && (index_metric || indexMetric) != null) {\n    if (method == null) method = 'GET';\n    path =\n      '/' +\n      '_nodes' +\n      '/' +\n      encodeURIComponent(node_id || nodeId) +\n      '/' +\n      'stats' +\n      '/' +\n      encodeURIComponent(metric) +\n      '/' +\n      encodeURIComponent(index_metric || indexMetric);\n  } else if ((node_id || nodeId) != null && metric != null) {\n    if (method == null) method = 'GET';\n    path =\n      '/' +\n      '_nodes' +\n      '/' +\n      encodeURIComponent(node_id || nodeId) +\n      '/' +\n      'stats' +\n      '/' +\n      encodeURIComponent(metric);\n  } else if (metric != null && (index_metric || indexMetric) != null) {\n    if (method == null) method = 'GET';\n    path =\n      '/' +\n      '_nodes' +\n      '/' +\n      'stats' +\n      '/' +\n      encodeURIComponent(metric) +\n      '/' +\n      encodeURIComponent(index_metric || indexMetric);\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'stats';\n  } else if (metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'stats' + '/' + encodeURIComponent(metric);\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'stats';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring,\n  };\n\n  return this.transport.request(request, options, callback);\n};\n\n/**\n * Returns low-level information about REST actions usage on nodes.\n * <br/> See Also: {@link https://opensearch.org/docs/latest/api-reference/nodes-apis/nodes-usage/ OpenSearch - Nodes Usage}\n * @memberOf API-Nodes\n *\n * @param {Object} params\n * @param {string} [params.node_id] - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes\n * @param {string} [params.metric] - Limit the information returned to the specified metrics (options: _all, rest_actions)\n * @param {string} [params.timeout] - Explicit operation timeout\n *\n * @param {Object} options - Options for {@link Transport#request}\n * @param {function} callback - Callback that handles errors and response\n *\n * @returns {{abort: function(), then: function(), catch: function()}|Promise<never>|*}\n */\nNodesApi.prototype.usage = function nodesUsageApi(params, options, callback) {\n  [params, options, callback] = normalizeArguments(params, options, callback);\n\n  let { method, body, nodeId, node_id, metric, ...querystring } = params;\n  querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring);\n\n  let path = '';\n  if ((node_id || nodeId) != null && metric != null) {\n    if (method == null) method = 'GET';\n    path =\n      '/' +\n      '_nodes' +\n      '/' +\n      encodeURIComponent(node_id || nodeId) +\n      '/' +\n      'usage' +\n      '/' +\n      encodeURIComponent(metric);\n  } else if ((node_id || nodeId) != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + encodeURIComponent(node_id || nodeId) + '/' + 'usage';\n  } else if (metric != null) {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'usage' + '/' + encodeURIComponent(metric);\n  } else {\n    if (method == null) method = 'GET';\n    path = '/' + '_nodes' + '/' + 'usage';\n  }\n\n  // build request object\n  const request = {\n    method,\n    path,\n    body: null,\n    querystring,\n  };\n\n  return this.transport.request(request, options, callback);\n};\n\nObject.defineProperties(NodesApi.prototype, {\n  clear_metering_archive: {\n    get() {\n      return this.clearMeteringArchive;\n    },\n  },\n  get_metering_info: {\n    get() {\n      return this.getMeteringInfo;\n    },\n  },\n  hot_threads: {\n    get() {\n      return this.hotThreads;\n    },\n  },\n  reload_secure_settings: {\n    get() {\n      return this.reloadSecureSettings;\n    },\n  },\n});\n\nmodule.exports = NodesApi;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}